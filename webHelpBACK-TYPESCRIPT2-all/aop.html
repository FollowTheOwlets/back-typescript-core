<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:34.9219455"><title>Аспектно-ориентированное программирование | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"-90qj5_2","level":0,"title":"О чем эта тема и зачем АОП","anchor":"#-90qj5_2"},{"id":"-90qj5_3","level":0,"title":"Базовые понятия","anchor":"#-90qj5_3"},{"id":"-90qj5_4","level":0,"title":"Схема взаимодействия (модель исполнения)","anchor":"#-90qj5_4"},{"id":"-90qj5_5","level":0,"title":"Типы советов (advices) и когда их применять","anchor":"#-90qj5_5"},{"id":"-90qj5_6","level":0,"title":"Способы сплетения (weaving)","anchor":"#-90qj5_6"},{"id":"-90qj5_7","level":0,"title":"Где применять АОП на практике","anchor":"#-90qj5_7"},{"id":"-90qj5_8","level":0,"title":"Минимальные примеры: один и тот же аспект логирования на пяти языках","anchor":"#-90qj5_8"},{"id":"-90qj5_9","level":0,"title":"Правила написания срезов (pointcuts) безопасно","anchor":"#-90qj5_9"},{"id":"-90qj5_10","level":0,"title":"Порядок и композиция аспектов","anchor":"#-90qj5_10"},{"id":"-90qj5_11","level":0,"title":"Асинхронность, потоки и контекст","anchor":"#-90qj5_11"},{"id":"-90qj5_12","level":0,"title":"Производительность","anchor":"#-90qj5_12"},{"id":"-90qj5_13","level":0,"title":"Тестирование и отладка аспектов","anchor":"#-90qj5_13"},{"id":"-90qj5_14","level":0,"title":"Когда нужен АОП?","anchor":"#-90qj5_14"},{"id":"-90qj5_15","level":0,"title":"Чеклист внедрения","anchor":"#-90qj5_15"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Аспектно-ориентированное программирование | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/aop.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Аспектно-ориентированное программирование | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/aop.html#webpage",
    "url": "writerside-documentation//1.0.0/aop.html",
    "name": "Аспектно-ориентированное программирование | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="AOP" data-main-title="Аспектно-ориентированное программирование" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_Theory.topic|Теория"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="AOP" id="AOP.topic">Аспектно-ориентированное программирование</h1><section class="chapter"><h2 id="-90qj5_2" data-toc="-90qj5_2">О чем эта тема и зачем АОП</h2><p id="-90qj5_16"><span id="-90qj5_18"><b>Аспектно-ориентированное программирование (АОП)</b></span> &mdash; подход, который помогает изолировать <span class="tooltip" id="-90qj5_19" title="Поведение, повторяющееся во многих местах системы (логирование, безопасность, метрики, транзакции).">сквозные функциональности</span> (логирование, метрики, безопасность, транзакции, кэширование) от бизнес-кода. Идея: вы описываете, <span id="-90qj5_20"><b>где</b></span> (в каких точках выполнения) и <span id="-90qj5_21"><b>что</b></span> делать дополнительно, а инфраструктура &laquo;вплетает&raquo; это поведение в ваш код автоматически.</p><aside class="prompt" data-type="note" data-title="" id="-90qj5_17"><p>АОП не заменяет ООП и паттерны. Это дополняющий слой, позволяющий держать нефункциональные требования отдельно от бизнес-логики.</p></aside></section><section class="chapter"><h2 id="-90qj5_3" data-toc="-90qj5_3">Базовые понятия</h2><p id="-90qj5_22"><span id="-90qj5_27"><b>Аспект</b></span> &mdash; модуль, в котором описано дополнительное поведение (советы) и критерии применения (<span class="tooltip" id="-90qj5_28" title="Выражение/правило, выбирающее множество точек соединения для применения советов.">срезы</span>).</p><p id="-90qj5_23"><span id="-90qj5_29"><b>Точка соединения (Join Point)</b></span> &mdash; конкретное место в выполнении программы (вызов метода, обработка исключения, доступ к полю), где аспект может быть применен.</p><p id="-90qj5_24"><span id="-90qj5_30"><b>Срез (Pointcut)</b></span> &mdash; выражение, отбирающее множество точек соединения (например, &laquo;все public-методы в пакете service..&raquo;).</p><p id="-90qj5_25"><span id="-90qj5_31"><b>Совет (Advice)</b></span> &mdash; код, исполняемый в выбранных точках: <span id="-90qj5_32"><b>before</b></span>, <span id="-90qj5_33"><b>after</b></span>, <span id="-90qj5_34"><b>after returning</b></span>, <span id="-90qj5_35"><b>after throwing</b></span>, <span id="-90qj5_36"><b>around</b></span> (обертка).</p><p id="-90qj5_26"><span id="-90qj5_37"><b>Сплетение (Weaving)</b></span> &mdash; процесс внедрения аспектов в приложение: на этапе компиляции, загрузки классов или во время выполнения (через <span class="tooltip" id="-90qj5_38" title="Промежуточный объект, перехватывающий вызовы для добавления поведения (интерсепторы, динамические прокси).">прокси</span> или модификацию байткода).</p></section><section class="chapter"><h2 id="-90qj5_4" data-toc="-90qj5_4">Схема взаимодействия (модель исполнения)</h2><ul class="list _bullet" id="-90qj5_39"><li class="list__item" id="-90qj5_41"><p>Клиент вызывает целевой метод.</p></li><li class="list__item" id="-90qj5_42"><p>Вызов проходит через инфраструктуру (прокси/интерсепторы), формируется цепочка аспектов.</p></li><li class="list__item" id="-90qj5_43"><p><span id="-90qj5_46"><b>Around</b></span>-совет получает контроль, может вызвать <code class="code" id="-90qj5_47">proceed()</code> для продолжения или прервать выполнение.</p></li><li class="list__item" id="-90qj5_44"><p>Внутри/после выполнения целевого метода срабатывают <span id="-90qj5_48"><b>before/after/after returning/after throwing</b></span>.</p></li><li class="list__item" id="-90qj5_45"><p>Результат (или исключение) возвращается, возможно, уже модифицированный аспектом.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="-90qj5_40"><p>Думайте об аспектах как о &laquo;слоях луковицы&raquo;: порядок подключения слоев определяет, что обернет что.</p></aside></section><section class="chapter"><h2 id="-90qj5_5" data-toc="-90qj5_5">Типы советов (advices) и когда их применять</h2><ul class="list _bullet" id="-90qj5_49"><li class="list__item" id="-90qj5_51"><p><span id="-90qj5_56"><b>Before</b></span> &mdash; валидация прав, привязка контекста трассировки, дешевые пред-проверки.</p></li><li class="list__item" id="-90qj5_52"><p><span id="-90qj5_57"><b>After</b></span> &mdash; очистка ресурсов, сброс контекста, публикация событий &laquo;всегда&raquo;.</p></li><li class="list__item" id="-90qj5_53"><p><span id="-90qj5_58"><b>After returning</b></span> &mdash; пост-обработка успешного результата, метрики &laquo;успех&raquo;.</p></li><li class="list__item" id="-90qj5_54"><p><span id="-90qj5_59"><b>After throwing</b></span> &mdash; унификация ошибок, метрики &laquo;ошибка&raquo;, алерты.</p></li><li class="list__item" id="-90qj5_55"><p><span id="-90qj5_60"><b>Around</b></span> &mdash; измерение времени, ретраи, таймауты, кэширование, транзакции.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="-90qj5_50"><p><span id="-90qj5_61"><b>Around</b></span> &mdash; самый гибкий, но и самый опасный тип: он отвечает за вызов целевого метода через <code class="code" id="-90qj5_62">proceed</code>. Неверное использование &mdash; частый источник багов.</p></aside></section><section class="chapter"><h2 id="-90qj5_6" data-toc="-90qj5_6">Способы сплетения (weaving)</h2><ul class="list _bullet" id="-90qj5_63"><li class="list__item" id="-90qj5_64"><p>Во время компиляции &mdash; модификация артефактов сборки. Плюсы: производительность. Минусы: сложность сборки.</p></li><li class="list__item" id="-90qj5_65"><p>При загрузке классов (LTW) &mdash; агенты/расширители загрузчика. Баланс гибкости и производительности.</p></li><li class="list__item" id="-90qj5_66"><p>Во время выполнения &mdash; динамические прокси/интерсепторы. Проще интегрировать, возможна цена в производительности.</p></li></ul></section><section class="chapter"><h2 id="-90qj5_7" data-toc="-90qj5_7">Где применять АОП на практике</h2><ul class="list _bullet" id="-90qj5_67"><li class="list__item" id="-90qj5_68"><p>Логирование и трассировка (корреляция запросов, <span class="tooltip" id="-90qj5_75" title="Набор идентификаторов (TraceId/SpanId), передаваемый через вызовы для сквозной корреляции логов/метрик.">контекст трассировки</span>).</p></li><li class="list__item" id="-90qj5_69"><p>Метрики (latency, error rate, счетчики вызовов).</p></li><li class="list__item" id="-90qj5_70"><p>Безопасность (проверка ролей/прав).</p></li><li class="list__item" id="-90qj5_71"><p>Транзакции и единицы работы.</p></li><li class="list__item" id="-90qj5_72"><p>Кэширование, дедупликация, <span class="tooltip" id="-90qj5_76" title="Свойство операции давать тот же эффект при повторном выполнении.">идемпотентность</span>.</p></li><li class="list__item" id="-90qj5_73"><p>Валидация входных данных, idempotency-keys, rate-limit.</p></li><li class="list__item" id="-90qj5_74"><p>Аудит и соответствие требованиям.</p></li></ul></section><section class="chapter"><h2 id="-90qj5_8" data-toc="-90qj5_8">Минимальные примеры: один и тот же аспект логирования на пяти языках</h2><div class="tabs" id="-90qj5_77" data-anchors="[-90qj5_79,-90qj5_80,-90qj5_81,-90qj5_82,-90qj5_83]"><div class="tabs__content" data-gtm="tab" id="-90qj5_79" data-title="Java (Spring AOP)"><div class="code-block" data-lang="java" data-title="Java">
                import org.aspectj.lang.ProceedingJoinPoint;
                import org.aspectj.lang.annotation.Around;
                import org.aspectj.lang.annotation.Aspect;
                import org.springframework.stereotype.Component;

                @Aspect
                @Component
                public class LoggingAspect {
                    @Around(&quot;execution(* com.example..service..*(..))&quot;)
                    public Object around(ProceedingJoinPoint pjp) throws Throwable {
                        long t0 = System.nanoTime();
                        try {
                            Object rs = pjp.proceed();
                            System.out.println(&quot;OK &quot; + pjp.getSignature() + &quot; took=&quot; + (System.nanoTime()-t0)/1_000_000 + &quot;ms&quot;); // output: OK ...
                            return rs;
                        } catch (Throwable ex) {
                            System.out.println(&quot;ERR &quot; + pjp.getSignature() + &quot; ex=&quot; + ex.getClass().getSimpleName()); // output: ERR ...
                            throw ex;
                        }
                    }
                }
                </div></div><div class="tabs__content" data-gtm="tab" id="-90qj5_80" data-title="TypeScript (метод-декоратор)"><div class="code-block" data-lang="ts" data-title="TypeScript">
function Log(): MethodDecorator {
    return (_t, _k, desc: PropertyDescriptor) =&gt; {
        const orig = desc.value;
        desc.value = async function (...args: any[]) {
            const t0 = performance.now();
            try {
                const rs = await orig.apply(this, args);
                console.log(&quot;OK&quot;, (performance.now() - t0).toFixed(2) + &quot;ms&quot;); // output: OK 3.12ms
                return rs;
            } catch (e) {
                console.log(&quot;ERR&quot;, (performance.now() - t0).toFixed(2) + &quot;ms&quot;); // output: ERR 1.02ms
                throw e;
            }
        };
    };
}

class Service {
    @Log()
    async work() {
        return 42;
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="-90qj5_81" data-title="JavaScript (Proxy)"><div class="code-block" data-lang="javascript" data-title="JavaScript">
function logProxy(obj) {
    return new Proxy(obj, {
        get(t, k, r) {
            const v = Reflect.get(t, k, r);
            if (typeof v !== &quot;function&quot;) return v;
            return async function (...args) {
                const t0 = performance.now();
                try {
                    const rs = await v.apply(this, args);
                    console.log(&quot;OK&quot;, k, (performance.now() - t0).toFixed(2) + &quot;ms&quot;); // output: OK method 2.01ms
                    return rs;
                } catch (e) {
                    console.log(&quot;ERR&quot;, k, (performance.now() - t0).toFixed(2) + &quot;ms&quot;); // output: ERR method 0.77ms
                    throw e;
                }
            };
        }
    });
}
</div></div><div class="tabs__content" data-gtm="tab" id="-90qj5_82" data-title="Go (HTTP middleware)"><div class="code-block" data-lang="go" data-title="Go">
package main

import (
&quot;log&quot;
&quot;net/http&quot;
&quot;time&quot;
)

func Log(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        t0 := time.Now()
        next.ServeHTTP(w, r)
        log.Println(&quot;OK&quot;, r.URL.Path, time.Since(t0)) // output: OK /api 12ms
    })
}

func main() {
    http.Handle(&quot;/api&quot;, Log(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte(&quot;hi&quot;))
    })))
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</div></div><div class="tabs__content" data-gtm="tab" id="-90qj5_83" data-title="C++ (RAII scope-aspect)"><div class="code-block" data-lang="cpp" data-title="CPP">
#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;

struct ScopeAspect {
    std::string name;
    std::chrono::high_resolution_clock::time_point t0;
    ScopeAspect(const std::string&amp; n): name(n), t0(std::chrono::high_resolution_clock::now()) {}
    ~ScopeAspect() {
        auto dt = std::chrono::duration_cast&lt;std: :chrono: :milliseconds&gt;(
        std::chrono::high_resolution_clock::now() - t0).count();
        std::cout &lt;&lt; &quot;OK &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; dt &lt;&lt; &quot;ms\n&quot;; // output: OK work 1ms
    }
};

int work() {
    ScopeAspect _a(&quot;work&quot;);
    return 42;
}
</div></div></div><aside class="prompt" data-type="tip" data-title="" id="-90qj5_78"><p>Примеры выше представляют &laquo;runtime-weaving&raquo;: вызов проходит через обертку/прокси/миддлвар. В JVM возможен LTW и компиляционное сплетение для ещё меньших накладных расходов.</p></aside></section><section class="chapter"><h2 id="-90qj5_9" data-toc="-90qj5_9">Правила написания срезов (pointcuts) безопасно</h2><ul class="list _bullet" id="-90qj5_89"><li class="list__item" id="-90qj5_91"><p>Отбирайте только нужные пакеты/классы/аннотации (минимальный охват).</p></li><li class="list__item" id="-90qj5_92"><p>Фильтруйте по сигнатурам: модификатор доступа, имя метода, количество/типы аргументов.</p></li><li class="list__item" id="-90qj5_93"><p>Используйте аннотации-маркеры для явного таргетинга.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-90qj5_90"><p>Слишком &laquo;широкий&raquo; срез приводит к неожиданным срабатываниям и деградации производительности.</p></aside></section><section class="chapter"><h2 id="-90qj5_10" data-toc="-90qj5_10">Порядок и композиция аспектов</h2><p id="-90qj5_94">Когда аспектов несколько, важен <span class="tooltip" id="-90qj5_96" title="Правило, задающее последовательность применения нескольких аспектов к одному вызову.">порядок</span>. Например: <span id="-90qj5_97"><b>трассировка</b></span> &mdash; внешняя оболочка, затем <span id="-90qj5_98"><b>аутентификация</b></span>, потом <span id="-90qj5_99"><b>транзакция</b></span>, затем <span id="-90qj5_100"><b>кэш</b></span>. Так вы получите корректные спаны, контролируемые транзакционные границы и метрики.</p><aside class="prompt" data-type="note" data-title="" id="-90qj5_95"><p>Фиксируйте порядок централизованно (приоритеты/ордеры). Документируйте мотивировку.</p></aside></section><section class="chapter"><h2 id="-90qj5_11" data-toc="-90qj5_11">Асинхронность, потоки и контекст</h2><p id="-90qj5_101">В асинхронном коде переносите контекст явно (TraceId, UserId), не полагайтесь только на ThreadLocal. Для реактивных/корутинных сред используйте инструменты контекст-пропагации фреймворка.</p><aside class="prompt" data-type="warning" data-title="" id="-90qj5_102"><p>Потеря контекста в асинхронных цепочках ломает корреляцию логов и трассировок.</p></aside></section><section class="chapter"><h2 id="-90qj5_12" data-toc="-90qj5_12">Производительность</h2><p id="-90qj5_103">Накладные расходы приходятся на построение цепочки перехватчиков, извлечение метаданных и возможные аллокации. <span id="-90qj5_105"><b>Around</b></span> может добавить 3&ndash;30% времени в горячих точках при большом числе аспектов. В критичных путях используйте LTW/compile-time или локальные обертки без рефлексии.</p><aside class="prompt" data-type="tip" data-title="" id="-90qj5_104"><p>Измеряйте P95/P99 до и после. Поддерживайте &laquo;ограниченный охват&raquo; и дешевые ветки для частых вызовов.</p></aside></section><section class="chapter"><h2 id="-90qj5_13" data-toc="-90qj5_13">Тестирование и отладка аспектов</h2><ul class="list _bullet" id="-90qj5_106"><li class="list__item" id="-90qj5_108"><p>Юнит-тесты для советов (проверка побочных эффектов и порядка вызовов).</p></li><li class="list__item" id="-90qj5_109"><p>Интеграционные тесты со &laquo;включенным&raquo; фреймворком и срезами.</p></li><li class="list__item" id="-90qj5_110"><p>Визуализация цепочек (логирование порядка срабатывания аспектов).</p></li></ul><aside class="prompt" data-type="note" data-title="" id="-90qj5_107"><p>Добавляйте &laquo;маркерные&raquo; логи начало/конец совета, чтобы видеть реальный порядок на проде.</p></aside></section><section class="chapter"><h2 id="-90qj5_14" data-toc="-90qj5_14">Когда нужен АОП?</h2><ul class="list _bullet" id="-90qj5_111"><li class="list__item" id="-90qj5_113"><p><span id="-90qj5_116"><b>Декоратор</b></span> &mdash; хороший выбор для нескольких целевых методов.</p></li><li class="list__item" id="-90qj5_114"><p><span id="-90qj5_117"><b>Middleware/пипелайн</b></span> &mdash; оптимален для HTTP/сообщений.</p></li><li class="list__item" id="-90qj5_115"><p><span id="-90qj5_118"><b>События/хуки</b></span> &mdash; когда важна реактивность и слабая связность.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-90qj5_112"><p>Если &laquo;сквозная&raquo; логика привязана к доменной модели и требует понимания бизнес-контекста &mdash; АОП может скрыть важную зависимость. Лучше вынести в явный сервис/паттерн.</p></aside></section><section class="chapter"><h2 id="-90qj5_15" data-toc="-90qj5_15">Чеклист внедрения</h2><ul class="list _bullet" id="-90qj5_119"><li class="list__item" id="-90qj5_120"><p>Выделите сквозные требования и зафиксируйте цели.</p></li><li class="list__item" id="-90qj5_121"><p>Определите точки соединения и критерии (срезы).</p></li><li class="list__item" id="-90qj5_122"><p>Выберите технику сплетения (compile/LTW/runtime).</p></li><li class="list__item" id="-90qj5_123"><p>Опишите порядок аспектов.</p></li><li class="list__item" id="-90qj5_124"><p>Покройте тестами и метриками, замерьте регресс производительности.</p></li><li class="list__item" id="-90qj5_125"><p>Документируйте правила добавления новых аспектов.</p></li></ul></section><div class="last-modified">24 сентября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="solid.html" class="navigation-links__prev">SOLID</a><a href="cop.html" class="navigation-links__next">Компонентно-ориентированная модель</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>