<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:34.9546409"><title>Движок V8 | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"ixu3mf_2","level":0,"title":"Зачем знать V8 (контекст и роли компонентов)","anchor":"#ixu3mf_2"},{"id":"ixu3mf_3","level":0,"title":"Что происходит при запуске node index.js (этапы выполнения)","anchor":"#ixu3mf_3"},{"id":"ixu3mf_4","level":0,"title":"Архитектура исполнения в V8 (интерпретатор и JIT-тираны)","anchor":"#ixu3mf_4"},{"id":"ixu3mf_5","level":0,"title":"Модель объектов, скрытые классы и inline caches","anchor":"#ixu3mf_5"},{"id":"ixu3mf_6","level":0,"title":"Массивы и их «виды элементов» (Elements Kinds)","anchor":"#ixu3mf_6"},{"id":"ixu3mf_7","level":0,"title":"Событийный цикл: фазы Node.js, задачи и микрозадачи","anchor":"#ixu3mf_7"},{"id":"ixu3mf_8","level":0,"title":"Пул потоков, I/O и CPU-bound задачи","anchor":"#ixu3mf_8"},{"id":"ixu3mf_9","level":0,"title":"Устройство сборки мусора в V8 (память и GC)","anchor":"#ixu3mf_9"},{"id":"ixu3mf_10","level":0,"title":"Чего избегать, чтобы не «холодить» JIT и не плодить деоптимизации","anchor":"#ixu3mf_10"},{"id":"ixu3mf_11","level":0,"title":"Практические шаблоны, хорошо дружащие с V8","anchor":"#ixu3mf_11"},{"id":"ixu3mf_12","level":0,"title":"Диагностика производительности и памяти (инструменты)","anchor":"#ixu3mf_12"},{"id":"ixu3mf_13","level":0,"title":"Микрозадачи: Promises, queueMicrotask и nextTick","anchor":"#ixu3mf_13"},{"id":"ixu3mf_14","level":0,"title":"Кейс: быстрота «холодного старта» vs длительная работа","anchor":"#ixu3mf_14"},{"id":"ixu3mf_15","level":0,"title":"Выводы","anchor":"#ixu3mf_15"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Движок V8 | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/v8.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Движок V8 | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/v8.html#webpage",
    "url": "writerside-documentation//1.0.0/v8.html",
    "name": "Движок V8 | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="V8" data-main-title="Движок V8" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_JavaScript.topic|JavaScript///NodeJS.topic|NodeJS"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="V8" id="V8.topic">Движок V8</h1><section class="chapter"><h2 id="ixu3mf_2" data-toc="ixu3mf_2">Зачем знать V8 (контекст и роли компонентов)</h2><p id="ixu3mf_16"><span class="tooltip" id="ixu3mf_19" title="Высокопроизводительный движок JavaScript от Google, используемый в Node.js">V8</span> &mdash; исполнительная платформа JavaScript (и <span class="tooltip" id="ixu3mf_20" title="Бинарный формат для высокопроизводительного кода в V8">WebAssembly</span>), которая в составе <span class="tooltip" id="ixu3mf_21" title="Среда выполнения JavaScript вне браузера">Node.js</span> вместе с <span class="tooltip" id="ixu3mf_22" title="Библиотека C для событийного цикла и неблокирующего I/O в Node.js">libuv</span> и системными библиотеками обеспечивает модель &laquo;один поток JavaScript + неблокирующий ввод-вывод&raquo;. Понимание внутренних механизмов V8 позволяет писать код, который быстрее запускается, устойчивее масштабируется и предсказуемее потребляет память.</p><ul class="list _bullet" id="ixu3mf_17"><li class="list__item" id="ixu3mf_23"><p><span id="ixu3mf_26"><b>V8</b></span> &mdash; парсит, интерпретирует, (JIT-)компилирует и выполняет ваш JS.</p></li><li class="list__item" id="ixu3mf_24"><p><span id="ixu3mf_27"><b>libuv</b></span> &mdash; реализует <span class="tooltip" id="ixu3mf_28" title="Механизм постановки и выполнения задач, обеспечивающий асинхронность в однопоточном JS">событийный цикл</span> (таймеры, сокеты, файловые операции, пул потоков).</p></li><li class="list__item" id="ixu3mf_25"><p><span id="ixu3mf_29"><b>Node.js bootstrap</b></span> &mdash; загружает рантайм-модули, создаёт <span class="tooltip" id="ixu3mf_30" title="Изолированная среда выполнения V8 с собственной кучей">изолят</span> и <span class="tooltip" id="ixu3mf_31" title="Глобальная среда (объект global/this, встроенные объекты) внутри изолята">контекст</span>, настраивает связи с V8.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="ixu3mf_18"><p>Взаимодействие простое по идее: JS код &rarr; V8 (парсинг &rarr; байткод &rarr; JIT) &rarr; планирование задач в libuv &rarr; обратные вызовы снова попадают в V8.</p></aside></section><section class="chapter"><h2 id="ixu3mf_3" data-toc="ixu3mf_3">Что происходит при запуске node index.js (этапы выполнения)</h2><p id="ixu3mf_32">При запуске <code class="code" id="ixu3mf_35">node index.js</code> происходит детерминированная цепочка шагов:</p><ul class="list _bullet" id="ixu3mf_33"><li class="list__item" id="ixu3mf_36"><p><span id="ixu3mf_44"><b>Инициализация рантайма</b></span>: процесс стартует, настраивается <code class="code" id="ixu3mf_45">Isolate</code>, создаётся глобальный <code class="code" id="ixu3mf_46">Context</code>, применяются настройки V8 (флаги, лимиты памяти), подготавливается <span class="tooltip" id="ixu3mf_47" title="Сериализованное начальное состояние V8 для быстрого старта">снапшот</span> с базовой средой.</p></li><li class="list__item" id="ixu3mf_37"><p><span id="ixu3mf_48"><b>Bootstrap Node.js</b></span>: поднимаются внутренние модули (<code class="code" id="ixu3mf_49">fs</code>, <code class="code" id="ixu3mf_50">net</code>, таймеры), связываются C++ биндинги и JS-обёртки.</p></li><li class="list__item" id="ixu3mf_38"><p><span id="ixu3mf_51"><b>Загрузка пользовательского модуля</b></span>: разрешение пути (CJS/ESM), чтение исходника, передача текста в V8.</p></li><li class="list__item" id="ixu3mf_39"><p><span id="ixu3mf_52"><b>Парсинг и подготовка</b></span>: лексер/парсер строят <span class="tooltip" id="ixu3mf_53" title="Абстрактное синтаксическое дерево — структура кода после парсинга">AST</span>, проводится привязка идентификаторов и лексических окружений.</p></li><li class="list__item" id="ixu3mf_40"><p><span id="ixu3mf_54"><b>Генерация байткода</b></span>: интерпретатор <span class="tooltip" id="ixu3mf_55" title="Интерпретатор V8, исполняющий байткод">Ignition</span> генерирует байткод из AST.</p></li><li class="list__item" id="ixu3mf_41"><p><span id="ixu3mf_56"><b>Исполнение и профиль</b></span>: байткод исполняется, собирается <span class="tooltip" id="ixu3mf_57" title="Типовая обратная связь, собираемая в рантайме для JIT">типовая обратная связь</span> в <span class="tooltip" id="ixu3mf_58" title="Структуры данных V8 для хранения обратной связи по операциям">feedback-векторах</span>.</p></li><li class="list__item" id="ixu3mf_42"><p><span id="ixu3mf_59"><b>JIT-компиляция по требованию</b></span>: &laquo;горячие&raquo; функции поднимаются по тиру: <span class="tooltip" id="ixu3mf_60" title="Baseline JIT-компилятор V8 для быстрого перевода байткода в машинный код">Sparkplug</span> (baseline) &rarr; <span class="tooltip" id="ixu3mf_61" title="Среднетировый оптимизирующий JIT в V8">Maglev</span> (mid-tier) &rarr; <span class="tooltip" id="ixu3mf_62" title="Главный оптимизирующий компилятор V8 на SSA-представлении">TurboFan</span> (оптимизатор полного профиля).</p></li><li class="list__item" id="ixu3mf_43"><p><span id="ixu3mf_63"><b>Сборка мусора</b></span>: периодически работают минорные/мажорные циклы GC, освобождая память.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="ixu3mf_34"><p>JIT запускается не сразу, а по мере &laquo;нагрева&raquo; кода. Путь к быстрым функциям &mdash; предсказуемые типы и стабильные объекты.</p></aside></section><section class="chapter"><h2 id="ixu3mf_4" data-toc="ixu3mf_4">Архитектура исполнения в V8 (интерпретатор и JIT-тираны)</h2><p id="ixu3mf_64">Современный V8 использует многоуровневый пайплайн, чтобы быстро стартовать и эффективно оптимизировать &laquo;горячие&raquo; участки:</p><ul class="list _bullet" id="ixu3mf_65"><li class="list__item" id="ixu3mf_68"><p><span id="ixu3mf_72"><b>Ignition</b></span> &mdash; байткодный интерпретатор: минимальный стартовый оверхед, сбор <code class="code" id="ixu3mf_73">type feedback</code>.</p></li><li class="list__item" id="ixu3mf_69"><p><span id="ixu3mf_74"><b>Sparkplug</b></span> &mdash; быстрый baseline JIT: переводит байткод в машинный код без дорогих анализов, снижая интерпретационный оверхед.</p></li><li class="list__item" id="ixu3mf_70"><p><span id="ixu3mf_75"><b>Maglev</b></span> &mdash; средний тировый оптимизатор: использует обратную связь и <span class="tooltip" id="ixu3mf_76" title="Кэшированные пути доступа к свойствам/вызовам методов для ускорения">IC</span>, делает агрессивные, но быстрые оптимизации.</p></li><li class="list__item" id="ixu3mf_71"><p><span id="ixu3mf_77"><b>TurboFan</b></span> &mdash; главный оптимизатор: строит высокоуровневое SSA-представление, делает инлайнинг, устранение боковых эффектов, <code class="code" id="ixu3mf_78">common subexpression elimination</code>, <code class="code" id="ixu3mf_79">bounds check elimination</code> и др.</p></li></ul><p id="ixu3mf_66">Все уровни зависят от корректности предположений о типах и &laquo;формах&raquo; объектов (см. <span class="tooltip" id="ixu3mf_80" title="Скрытый класс (Map) — форма объекта со схемой свойств">скрытые классы</span>). Если предположения рушатся в рантайме, происходит <span class="tooltip" id="ixu3mf_81" title="Откат оптимизированного кода при нарушении предположений">деоптимизация</span> (откат до ранее сгенерированного кода или байткода).</p><aside class="prompt" data-type="warning" data-title="" id="ixu3mf_67"><p>Частые изменения структуры объектов, смешение типов в массивах, использование &laquo;магических&raquo; возможностей (например, динамический <code class="code" id="ixu3mf_82">eval</code>) увеличивают риск деоптимизаций и &laquo;холодят&raquo; код.</p></aside></section><section class="chapter"><h2 id="ixu3mf_5" data-toc="ixu3mf_5">Модель объектов, скрытые классы и inline caches</h2><p id="ixu3mf_83">Объекты в V8 имеют &laquo;карту&raquo; &mdash; <span class="tooltip" id="ixu3mf_88" title="Скрытый класс (Map) — форма объекта со схемой свойств">скрытый класс</span> (в терминах V8 &mdash; <code class="code" id="ixu3mf_89">Map</code>), который фиксирует набор и порядок свойств, а также оффсеты хранения. Доступ к свойству оптимизируется через <span class="tooltip" id="ixu3mf_90" title="Кэшированные пути доступа к свойствам/вызовам методов для ускорения">IC</span>, которые запоминают &laquo;как мы находили это свойство в прошлый раз&raquo;.</p><ul class="list _bullet" id="ixu3mf_84"><li class="list__item" id="ixu3mf_91"><p><span id="ixu3mf_93"><b>Стабильные формы</b></span>: если вы создаёте однотипные объекты и добавляете свойства в одном и том же порядке &mdash; IC остаются моно-/полиморфными и быстрыми.</p></li><li class="list__item" id="ixu3mf_92"><p><span id="ixu3mf_94"><b>Разрушение форм</b></span>: добавление/удаление свойств в разном порядке, <code class="code" id="ixu3mf_95">delete</code>, доступ через строки с разным набором ключей приводит к &laquo;мегаморфизму&raquo; IC и деградации.</p></li></ul><div class="code-block" data-lang="javascript">
        function makeUser(id, name) {
            return {id, name};
        }

        const a = makeUser(1, 'Ann');
        const b = makeUser(2, 'Bob');
        console.log(a.id + b.id); // 3
        </div><aside class="prompt" data-type="tip" data-title="" id="ixu3mf_86"><p>Если нужно опциональное поле &mdash; заранее инициализируйте его значением <code class="code" id="ixu3mf_96">null</code>, чтобы сохранить форму объекта стабильной.</p></aside><aside class="prompt" data-type="warning" data-title="" id="ixu3mf_87"><p><code class="code" id="ixu3mf_97">delete obj.key</code> ломает скрытый класс. Лучше использовать <code class="code" id="ixu3mf_98">Map</code> для динамических наборов ключей.</p></aside></section><section class="chapter"><h2 id="ixu3mf_6" data-toc="ixu3mf_6">Массивы и их &laquo;виды элементов&raquo; (Elements Kinds)</h2><p id="ixu3mf_99">У массивов V8 различает &laquo;виды элементов&raquo; (<span class="tooltip" id="ixu3mf_103" title="Вид элементов массива (packed, holey, smi, double, dictionary)">elements kinds</span>): <code class="code" id="ixu3mf_104">Packed Smi</code> (целые), <code class="code" id="ixu3mf_105">Packed Double</code> (числа с плавающей точкой), <code class="code" id="ixu3mf_106">Holey</code> (с &laquo;дырами&raquo;), <code class="code" id="ixu3mf_107">Dictionary</code> (редкие/спарс). Переходы между видами дороги и ломают оптимизации.</p><ul class="list _bullet" id="ixu3mf_100"><li class="list__item" id="ixu3mf_108"><p>Держите массивы плотными (<span id="ixu3mf_111"><b>packed</b></span>): не создавайте больших &laquo;дыр&raquo; (<code class="code" id="ixu3mf_112">a[1e6] = 1</code>).</p></li><li class="list__item" id="ixu3mf_109"><p>Не смешивайте типы: числа + строки в одном массиве &rarr; переход к &laquo;generic&raquo; представлению.</p></li><li class="list__item" id="ixu3mf_110"><p>Избегайте частых <code class="code" id="ixu3mf_113">unshift</code>/<code class="code" id="ixu3mf_114">splice</code> в начале &mdash; это дороже, чем <code class="code" id="ixu3mf_115">push</code>/<code class="code" id="ixu3mf_116">pop</code>.</p></li></ul><div class="code-block" data-lang="javascript">
        const a = [1, 2, 3];
        a.push(4);
        console.log(a.length); // 4 </div><aside class="prompt" data-type="warning" data-title="" id="ixu3mf_102"><p>Назначение <code class="code" id="ixu3mf_117">arr.length = N</code> с большим <code class="code" id="ixu3mf_118">N</code> создаёт &laquo;дыры&raquo;, ухудшая представление.</p></aside></section><section class="chapter"><h2 id="ixu3mf_7" data-toc="ixu3mf_7">Событийный цикл: фазы Node.js, задачи и микрозадачи</h2><p id="ixu3mf_119">В Node.js событийный цикл (<span class="tooltip" id="ixu3mf_123" title="Событийный цикл — механизм поэтапного исполнения задач и I/O">event loop</span>) реализован в <span class="tooltip" id="ixu3mf_124" title="Библиотека C для событийного цикла и неблокирующего I/O в Node.js">libuv</span> и имеет фазы: <span id="ixu3mf_125"><b>timers</b></span> &rarr; <span id="ixu3mf_126"><b>pending callbacks</b></span> &rarr; <span id="ixu3mf_127"><b>idle/prepare</b></span> &rarr; <span id="ixu3mf_128"><b>poll</b></span> &rarr; <span id="ixu3mf_129"><b>check</b></span> &rarr; <span id="ixu3mf_130"><b>close callbacks</b></span>. Между вызовами коллбеков V8 &laquo;сливает&raquo; <span class="tooltip" id="ixu3mf_131" title="Очередь микрозадач (Promises, queueMicrotask)">очередь микрозадач</span> (Promises/queueMicrotask). Отдельно в Node есть очередь <code class="code" id="ixu3mf_132">process.nextTick</code>, обрабатываемая раньше микрозадач.</p><div class="code-block" data-lang="javascript">
        setTimeout(() =&gt; console.log('timeout'), 0);
        setImmediate(() =&gt; console.log('immediate'));
        Promise.resolve().then(() =&gt; console.log('microtask'));
        process.nextTick(() =&gt; console.log('nextTick'));
        // Возможный порядок вывода в консоли:
        // nextTick
        // microtask
        // timeout или immediate (зависит от того, была ли I/O и текущей фазы)
        </div><aside class="prompt" data-type="tip" data-title="" id="ixu3mf_121"><p><code class="code" id="ixu3mf_133">process.nextTick</code> &mdash; инструмент для &laquo;немедленного&raquo; продолжения текущей задачи, используйте умеренно: бесконечное перепланирование &laquo;съест&raquo; цикл и задержит I/O.</p></aside><aside class="prompt" data-type="note" data-title="" id="ixu3mf_122"><p><code class="code" id="ixu3mf_134">setImmediate</code> вызывается на фазе <code class="code" id="ixu3mf_135">check</code>, тогда как <code class="code" id="ixu3mf_136">setTimeout(0)</code> &mdash; на фазе <code class="code" id="ixu3mf_137">timers</code>. После I/O <code class="code" id="ixu3mf_138">setImmediate</code> обычно срабатывает раньше.</p></aside></section><section class="chapter"><h2 id="ixu3mf_8" data-toc="ixu3mf_8">Пул потоков, I/O и CPU-bound задачи</h2><p id="ixu3mf_139">Node.js делегирует часть операций в <span id="ixu3mf_143"><b>пул потоков</b></span> libuv (по умолчанию 4): файловая система, DNS (без <code class="code" id="ixu3mf_144">c-ares</code>), крипто, сжатие. Эти задачи асинхронны относительно главного JS-потока.</p><ul class="list _bullet" id="ixu3mf_140"><li class="list__item" id="ixu3mf_145"><p><span id="ixu3mf_148"><b>I/O-bound</b></span>: оставляйте в главном потоке &mdash; коллбеки вернутся через цикл событий.</p></li><li class="list__item" id="ixu3mf_146"><p><span id="ixu3mf_149"><b>CPU-bound</b></span>: переносите в <span class="tooltip" id="ixu3mf_150" title="Модель параллельных JS-воркеров для CPU-bound задач">worker threads</span> &mdash; иначе вы &laquo;заморозите&raquo; цикл и всё приложение.</p></li><li class="list__item" id="ixu3mf_147"><p>Параметр <code class="code" id="ixu3mf_151">UV_THREADPOOL_SIZE</code> регулирует размер пула (для I/O-задач), но не решает CPU-bound проблемы.</p></li></ul><div class="code-block" data-lang="javascript">
// Пример наблюдаемого эффекта:
const start = Date.now();
// Имитация тяжёлой синхронной операции:
while (Date.now() - start &lt; 300) {}
console.log('heavy done'); // heavy done
        </div><aside class="prompt" data-type="warning" data-title="" id="ixu3mf_142"><p>Синхронные тяжёлые циклы блокируют обработку всех соединений. Для вычислений используйте <code class="code" id="ixu3mf_152">worker_threads</code>.</p></aside></section><section class="chapter"><h2 id="ixu3mf_9" data-toc="ixu3mf_9">Устройство сборки мусора в V8 (память и GC)</h2><p id="ixu3mf_153">Память V8 разбита на пространства: <span id="ixu3mf_157"><b>New Space</b></span> (молодое), <span id="ixu3mf_158"><b>Old Space</b></span> (старое), <span id="ixu3mf_159"><b>Large Object Space</b></span> (крупные объекты), <span id="ixu3mf_160"><b>Code Space</b></span> (машинный код), <span id="ixu3mf_161"><b>Read-only Space</b></span> и др. Молодое пространство собирается часто и быстро (<span class="tooltip" id="ixu3mf_162" title="Минорный сборщик мусора (молодое поколение, копирующий)">минорный GC</span>, копирующий), старое &mdash; реже и тяжелее (<span class="tooltip" id="ixu3mf_163" title="Мажорный сборщик мусора (старое поколение, mark-sweep/compact)">мажорный GC</span>: mark-sweep/mark-compact, инкрементальный и параллельный).</p><ul class="list _bullet" id="ixu3mf_154"><li class="list__item" id="ixu3mf_164"><p><span id="ixu3mf_167"><b>Generational hypothesis</b></span>: &laquo;большинство объектов живут недолго&raquo;. Короткоживущие погибают в New Space; выжившие &laquo;продвигаются&raquo; в Old Space.</p></li><li class="list__item" id="ixu3mf_165"><p><span id="ixu3mf_168"><b>Write barriers</b></span> и <span id="ixu3mf_169"><b>remembered set</b></span>: отслеживают ссылки из старого в молодое, чтобы минорный GC был корректным.</p></li><li class="list__item" id="ixu3mf_166"><p><span id="ixu3mf_170"><b>Compaction</b></span>: мажорный GC может &laquo;уплотнять&raquo; кучу, уменьшая фрагментацию.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="ixu3mf_155"><p>Долгоживущие крупные структуры (кэш без ограничений, глобальные массивы) быстро переполняют Old Space и вызывают &laquo;фризы&raquo; на мажорных GC.</p></aside><aside class="prompt" data-type="tip" data-title="" id="ixu3mf_156"><p>Освобождайте ссылки (обнуляйте/обрезайте массивы, очищайте карты/сеты), когда данные больше не нужны. Следите за количеством активных таймеров и слушателей событий.</p></aside></section><section class="chapter"><h2 id="ixu3mf_10" data-toc="ixu3mf_10">Чего избегать, чтобы не &laquo;холодить&raquo; JIT и не плодить деоптимизации</h2><ul class="list _bullet" id="ixu3mf_171"><li class="list__item" id="ixu3mf_174"><p><span id="ixu3mf_180"><b>Мегаморфные IC</b></span>: не смешивайте в одном месте доступа к свойствам десятки &laquo;форм&raquo; объектов.</p></li><li class="list__item" id="ixu3mf_175"><p><span id="ixu3mf_181"><b>Смешанные массивы</b></span>: не храните в одном массиве числа и строки/объекты; не создавайте &laquo;дыр&raquo;.</p></li><li class="list__item" id="ixu3mf_176"><p><span id="ixu3mf_182"><b>delete</b></span>: не удаляйте свойства у горячих объектов &mdash; меняйте модель данных (используйте <code class="code" id="ixu3mf_183">Map</code> или логические флаги).</p></li><li class="list__item" id="ixu3mf_177"><p><span id="ixu3mf_184"><b>arguments</b></span>: не &laquo;мапьте&raquo; и не мутируйте его; используйте <code class="code" id="ixu3mf_185">...rest</code>.</p></li><li class="list__item" id="ixu3mf_178"><p><span id="ixu3mf_186"><b>eval / with</b></span>: ломают статический анализ и оптимизации.</p></li><li class="list__item" id="ixu3mf_179"><p><span id="ixu3mf_187"><b>Исключения в &laquo;узких&raquo; циклах</b></span>: <code class="code" id="ixu3mf_188">try/catch</code> в горячих путях может препятствовать оптимизациям.</p></li></ul><div class="code-block" data-lang="javascript">
        function sum(...xs) {
            return xs.reduce((a, b) =&gt; a + b, 0);
        }

        console.log(sum(1, 2, 3)); // 6 </div><aside class="prompt" data-type="note" data-title="" id="ixu3mf_173"><p>Переход на <code class="code" id="ixu3mf_189">rest</code>-параметры облегчает оптимизацию, в отличие от &laquo;волшебного&raquo; <code class="code" id="ixu3mf_190">arguments</code>.</p></aside></section><section class="chapter"><h2 id="ixu3mf_11" data-toc="ixu3mf_11">Практические шаблоны, хорошо дружащие с V8</h2><ul class="list _bullet" id="ixu3mf_191"><li class="list__item" id="ixu3mf_193"><p><span id="ixu3mf_199"><b>Стабилизируйте формы</b></span>: объявляйте все поля объекта в конструкторе/фабрике, даже если часть временно <code class="code" id="ixu3mf_200">null</code>.</p></li><li class="list__item" id="ixu3mf_194"><p><span id="ixu3mf_201"><b>Типизируйте коллекции</b></span>: &laquo;масив чисел&raquo; &mdash; это реально только числа; для гетерогенных данных используйте объекты/классы.</p></li><li class="list__item" id="ixu3mf_195"><p><span id="ixu3mf_202"><b>Используйте Map/Set</b></span> для словарей/множеств вместо &laquo;объектов-ассоциативных массивов&raquo;.</p></li><li class="list__item" id="ixu3mf_196"><p><span id="ixu3mf_203"><b>TypedArray</b></span> и <code class="code" id="ixu3mf_204">ArrayBuffer</code> &mdash; для плотных числовых данных и работы с бинарными протоколами.</p></li><li class="list__item" id="ixu3mf_197"><p><span id="ixu3mf_205"><b>Разделяйте I/O и CPU</b></span>: тяжёлые вычисления &mdash; в <code class="code" id="ixu3mf_206">worker_threads</code>.</p></li><li class="list__item" id="ixu3mf_198"><p><span id="ixu3mf_207"><b>Корректно &laquo;уступайте&raquo; циклу</b></span>: используйте <code class="code" id="ixu3mf_208">setImmediate</code>/<code class="code" id="ixu3mf_209">setTimeout</code> для батчинга, не злоупотребляйте <code class="code" id="ixu3mf_210">nextTick</code>.</p></li></ul><div class="code-block" data-lang="javascript"> // Порядок и полный набор полей фиксируют форму: function makePoint(x, y) { return { x, y, z: 0, tag: null }; } const p = makePoint(1, 2); console.log(p.z); // 0 </div></section><section class="chapter"><h2 id="ixu3mf_12" data-toc="ixu3mf_12">Диагностика производительности и памяти (инструменты)</h2><p id="ixu3mf_211">Для анализа существуют встроенные флаги и внешние профайлеры: <code class="code" id="ixu3mf_215">--trace_gc</code>, <code class="code" id="ixu3mf_216">--trace_gc_verbose</code>, <code class="code" id="ixu3mf_217">--inspect</code>, <code class="code" id="ixu3mf_218">--heap-prof</code>, <code class="code" id="ixu3mf_219">--cpu-prof</code>. Подключение Chrome DevTools к Node позволяет снимать <span class="tooltip" id="ixu3mf_220" title="Снимок кучи для анализа удерживаемых объектов и утечек">снимки кучи</span>, анализировать ретейнеры и утечки.</p><ul class="list _bullet" id="ixu3mf_212"><li class="list__item" id="ixu3mf_221"><p><span id="ixu3mf_224"><b>CPU profile</b></span>: найдите &laquo;горячие&raquo; функции, убедитесь, что они оптимизированы (нет постоянных деоптимизаций).</p></li><li class="list__item" id="ixu3mf_222"><p><span id="ixu3mf_225"><b>Heap snapshot</b></span>: проверяйте рост Old Space; ищите &laquo;корни&raquo;, удерживающие большие структуры.</p></li><li class="list__item" id="ixu3mf_223"><p><span id="ixu3mf_226"><b>GC traces</b></span>: следите за частотой minor/major GC и длительностью пауз.</p></li></ul><div class="code-block" data-lang="javascript"> // Наблюдение за ростом памяти: const big = []; for (let i = 0; i &lt; 1e4; i++) big.push(Buffer.alloc(1024)); console.log(process.memoryUsage().heapUsed &gt; 0); // true </div><aside class="prompt" data-type="tip" data-title="" id="ixu3mf_214"><p>Флаги <code class="code" id="ixu3mf_227">--max-old-space-size=&lt;MB&gt;</code> пригодны для контейнеров, чтобы ограничивать память и управлять частотой GC.</p></aside></section><section class="chapter"><h2 id="ixu3mf_13" data-toc="ixu3mf_13">Микрозадачи: Promises, queueMicrotask и nextTick</h2><p id="ixu3mf_228">V8 поддерживает общую очередь микрозадач: <code class="code" id="ixu3mf_231">Promise.then</code>/<code class="code" id="ixu3mf_232">queueMicrotask</code>. В Node.js есть ещё <code class="code" id="ixu3mf_233">process.nextTick</code>, исполняющийся раньше любой микрозадачи. Понимание порядка важно для детерминизма.</p><div class="code-block" data-lang="javascript">
Promise.resolve().then(() =&gt;
console.log('promise'));
queueMicrotask(() =&gt; console.log('microtask'));
process.nextTick(() =&gt; console.log('tick'));
// Порядок:
// tick
// promise
// microtask
        </div><aside class="prompt" data-type="warning" data-title="" id="ixu3mf_230"><p>Не строите бесконечных цепочек <code class="code" id="ixu3mf_234">nextTick</code>: вы заблокируете I/O и timers фазу.</p></aside></section><section class="chapter"><h2 id="ixu3mf_14" data-toc="ixu3mf_14">Кейс: быстрота &laquo;холодного старта&raquo; vs длительная работа</h2><p id="ixu3mf_235"><span id="ixu3mf_237"><b>Sparkplug</b></span> даёт быстрый выигрыш на старте (меньше интерпретации), а <span id="ixu3mf_238"><b>TurboFan</b></span> раскрывается на длительных прогревах. В CLI-утилитах &laquo;холодный старт&raquo; критичнее, чем &laquo;долгая оптимизация&raquo;, а в серверных службах &mdash; наоборот.</p><aside class="prompt" data-type="note" data-title="" id="ixu3mf_236"><p>Оптимизируйте то, что действительно &laquo;горит&raquo; по профилю. Ранние микрооптимизации без данных &mdash; частая причина ухудшения читаемости кода без измеримого выигрыша.</p></aside></section><section class="chapter"><h2 id="ixu3mf_15" data-toc="ixu3mf_15">Выводы</h2><ul class="list _bullet" id="ixu3mf_239"><li class="list__item" id="ixu3mf_240"><p>Объекты: фиксируйте набор и порядок свойств, избегайте <code class="code" id="ixu3mf_247">delete</code>.</p></li><li class="list__item" id="ixu3mf_241"><p>Массивы: держите плотными и однотипными, без &laquo;дыр&raquo;.</p></li><li class="list__item" id="ixu3mf_242"><p>Асинхронщина: используйте <code class="code" id="ixu3mf_248">Promise</code>/<code class="code" id="ixu3mf_249">async/await</code>, не злоупотребляйте <code class="code" id="ixu3mf_250">nextTick</code>.</p></li><li class="list__item" id="ixu3mf_243"><p>I/O vs CPU: отделяйте; CPU &mdash; в <code class="code" id="ixu3mf_251">worker_threads</code>.</p></li><li class="list__item" id="ixu3mf_244"><p>Память: ограничивайте кэши, снимайте <code class="code" id="ixu3mf_252">heap snapshot</code>, ищите долгоживущие ссылки.</p></li><li class="list__item" id="ixu3mf_245"><p>Профилируйте: <code class="code" id="ixu3mf_253">--inspect</code>, CPU/Heap профили, <code class="code" id="ixu3mf_254">--trace_gc</code>.</p></li><li class="list__item" id="ixu3mf_246"><p>Конфигурация: корректный <code class="code" id="ixu3mf_255">--max-old-space-size</code> для контейнеров.</p></li></ul></section><div class="last-modified">24 сентября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="npm.html" class="navigation-links__prev">Импорт, экспорт. Пакеты</a><a href="theory.html" class="navigation-links__next">Теория</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>