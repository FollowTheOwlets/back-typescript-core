<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:35.1394898"><title>SOLID | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"q3j53s_2","level":0,"title":"Принципы SOLID и их связь с ООП","anchor":"#q3j53s_2"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="SOLID | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/solid.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="SOLID | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/solid.html#webpage",
    "url": "writerside-documentation//1.0.0/solid.html",
    "name": "SOLID | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="SOLID" data-main-title="SOLID" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_Theory.topic|Теория"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="SOLID" id="SOLID.topic">SOLID</h1><section class="chapter"><h2 id="q3j53s_2" data-toc="q3j53s_2">Принципы SOLID и их связь с ООП</h2><p id="q3j53s_3"><span id="q3j53s_11"><b>SOLID</b></span> &mdash; это набор пяти принципов проектирования объектно-ориентированных систем. Они формулируют, как правильно применять базовые возможности ООП: наследование, инкапсуляцию, полиморфизм и абстракцию. Фактически, <span class="tooltip" id="q3j53s_12" title="Набор из пяти принципов проектирования объектного кода">SOLID</span> &mdash; это мост между &laquo;теорией&raquo; объектно-ориентированного подхода и &laquo;практикой&raquo; написания гибкого и поддерживаемого кода.</p><aside class="prompt" data-type="note" data-title="" id="q3j53s_4"><p>Вы можете воспринимать SOLID как &laquo;развернутую инструкцию&raquo;, которая объясняет, как использовать ООП так, чтобы код был понятным, расширяемым и устойчивым к изменениям.</p></aside><section class="chapter"><h3 id="q3j53s_5" data-toc="q3j53s_5">S &mdash; Single Responsibility Principle (Принцип единственной ответственности)</h3><p id="q3j53s_13">Каждый класс должен отвечать только за одну задачу. Этот принцип напрямую связан с <span class="tooltip" id="q3j53s_19" title="Сокрытие внутренних деталей реализации за публичным интерфейсом">инкапсуляцией</span>: скрывая детали реализации, мы выделяем чёткие зоны ответственности.</p><ul class="list _bullet" id="q3j53s_14"><li class="list__item" id="q3j53s_20"><p>ООП даёт инструмент &mdash; <span class="tooltip" id="q3j53s_22" title="Синтаксическая обёртка над прототипами с поддержкой constructor, методов, static и наследования.">класс</span>.</p></li><li class="list__item" id="q3j53s_21"><p>SOLID уточняет: класс должен инкапсулировать одну ответственность, а не десятки.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="q3j53s_15"><p>Класс, у которого слишком много обязанностей (&laquo;God Object&raquo;), нарушает SRP. Такие классы трудно тестировать, сопровождать и менять.</p></aside><aside class="prompt" data-type="tip" data-title="" id="q3j53s_16"><p>Чтобы проверить, нарушаете ли вы SRP, задайте вопрос: &laquo;Если изменится бизнес-правило X, изменится ли этот класс?&raquo; Если ответ &laquo;да&raquo; для нескольких несвязанных правил &mdash; ответственность раздвоена.</p></aside><p id="q3j53s_17">Схема для SRP:</p><figure id="q3j53s_18"><img alt="Принцип SRP" src="images/srp.png" title="Принцип SRP" width="930" height="343"></figure></section><section class="chapter"><h3 id="q3j53s_6" data-toc="q3j53s_6">O &mdash; Open/Closed Principle (Принцип открытости-закрытости)</h3><p id="q3j53s_23">Программные сущности должны быть <span id="q3j53s_28"><b>открыты для расширения</b></span>, но <span id="q3j53s_29"><b>закрыты для изменения</b></span>. Это прямое следствие <span class="tooltip" id="q3j53s_30" title="Выделение существенных характеристик и игнорирование несущестенных деталей">абстракции</span> и <span class="tooltip" id="q3j53s_31" title="Способность объектов разных классов отвечать на один и тот же интерфейс по-разному">полиморфизма</span>.</p><ul class="list _bullet" id="q3j53s_24"><li class="list__item" id="q3j53s_32"><p>ООП даёт нам <span class="tooltip" id="q3j53s_34" title="Контракт, определяющий набор доступных методов без реализации">интерфейсы</span> и <span class="tooltip" id="q3j53s_35" title="Класс с неполной реализацией, не допускающий непосредственного создания экземпляра">абстрактные классы</span>.</p></li><li class="list__item" id="q3j53s_33"><p>SOLID говорит: расширяйте поведение через новые реализации, а не меняйте старый код.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="q3j53s_25"><p>Например, если нужно добавить новый тип фигуры (Треугольник), мы создаём новый класс, реализующий интерфейс Shape, а не меняем уже существующие классы.</p></aside><p id="q3j53s_26">Схема для OCP:</p><figure id="q3j53s_27"><img alt="Принцип OCP" src="images/ocp.png" title="Принцип OCP" width="824" height="302"></figure></section><section class="chapter"><h3 id="q3j53s_7" data-toc="q3j53s_7">L &mdash; Liskov Substitution Principle (Принцип подстановки Барбары Лисков)</h3><p id="q3j53s_36">Подклассы должны быть взаимозаменяемы с базовыми классами. Этот принцип уточняет, как использовать <span id="q3j53s_42"><b>наследование</b></span>. Если класс <code class="code" id="q3j53s_43">B</code> наследуется от класса <code class="code" id="q3j53s_44">A</code>, то любой код, работающий с <code class="code" id="q3j53s_45">A</code>, должен корректно работать и с <code class="code" id="q3j53s_46">B</code>.</p><ul class="list _bullet" id="q3j53s_37"><li class="list__item" id="q3j53s_47"><p>ООП даёт наследование и полиморфизм.</p></li><li class="list__item" id="q3j53s_48"><p>SOLID требует: наследование должно сохранять инварианты и ожидания базового класса.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="q3j53s_38"><p>Если подкласс нарушает контракты родителя (например, <code class="code" id="q3j53s_49">Square extends Rectangle</code>, но ломает логику ширины и высоты), то нарушается принцип Лисков.</p></aside><aside class="prompt" data-type="note" data-title="" id="q3j53s_39"><p>Для практики: тестируйте подклассы так, как будто это объекты базового класса. Если что-то ломается &mdash; принцип нарушен.</p></aside><p id="q3j53s_40">Схема для LSP:</p><figure id="q3j53s_41"><img alt="Принцип LSP" src="images/lsp.png" title="Принцип LSP" width="917" height="429"></figure></section><section class="chapter"><h3 id="q3j53s_8" data-toc="q3j53s_8">I &mdash; Interface Segregation Principle (Принцип разделения интерфейсов)</h3><p id="q3j53s_50">Клиенты не должны зависеть от методов, которые они не используют. Это расширение идеи <span class="tooltip" id="q3j53s_56" title="Выделение существенных характеристик и игнорирование несущестенных деталей">абстракции</span> и <span class="tooltip" id="q3j53s_57" title="Контракт, определяющий набор доступных методов без реализации">интерфейсов</span>.</p><ul class="list _bullet" id="q3j53s_51"><li class="list__item" id="q3j53s_58"><p>ООП позволяет объявлять интерфейсы или абстрактные классы.</p></li><li class="list__item" id="q3j53s_59"><p>SOLID говорит: делите их на небольшие, специализированные интерфейсы.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="q3j53s_52"><p>Большие интерфейсы (например, &laquo;God Interface&raquo;) заставляют клиентов реализовывать ненужные методы. Это ведёт к &laquo;пустым&raquo; или фиктивным реализациям.</p></aside><aside class="prompt" data-type="note" data-title="" id="q3j53s_53"><p>Лучше несколько мелких интерфейсов, чем один универсальный. Например, разделяйте <code class="code" id="q3j53s_60">Printer</code> и <code class="code" id="q3j53s_61">Scanner</code> вместо <code class="code" id="q3j53s_62">IMultiFunctionDevice</code>.</p></aside><p id="q3j53s_54">Схема для ISP:</p><figure id="q3j53s_55"><img alt="Принцип ISP" src="images/isp.png" title="Принцип ISP" width="1130" height="462"></figure></section><section class="chapter"><h3 id="q3j53s_9" data-toc="q3j53s_9">D &mdash; Dependency Inversion Principle (Принцип инверсии зависимостей)</h3><p id="q3j53s_63">Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа должны зависеть от абстракций. Это развитие идеи <span class="tooltip" id="q3j53s_68" title="Способность объектов разных классов отвечать на один и тот же интерфейс по-разному">полиморфизма</span> и <span class="tooltip" id="q3j53s_69" title="Сокрытие внутренних деталей реализации за публичным интерфейсом">инкапсуляции</span>.</p><ul class="list _bullet" id="q3j53s_64"><li class="list__item" id="q3j53s_70"><p>ООП даёт абстракции (интерфейсы, базовые классы).</p></li><li class="list__item" id="q3j53s_71"><p>SOLID формулирует: связывайтесь через абстракцию, а не через конкретику.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="q3j53s_65"><p>Пример: контроллер обращается к <code class="code" id="q3j53s_72">Repository</code> через интерфейс, а не напрямую к конкретной базе данных. Тогда заменить хранилище можно без переписывания контроллера.</p></aside><p id="q3j53s_66">Схема для DIP:</p><figure id="q3j53s_67"><img alt="Принцип DIP" src="images/dip.png" title="Принцип DIP" width="1145" height="561"></figure></section><section class="chapter"><h3 id="q3j53s_10" data-toc="q3j53s_10">Вывод: ООП &rarr; SOLID и обратно</h3><p id="q3j53s_73">SOLID не вводит новых сущностей, которых нет в ООП. Он лишь уточняет, <span id="q3j53s_76"><b>как правильно применять ООП</b></span>. Принципы ООП дают инструменты: классы, объекты, наследование, инкапсуляцию, полиморфизм. Принципы SOLID говорят, как пользоваться этими инструментами, чтобы избежать ошибок.</p><ul class="list _bullet" id="q3j53s_74"><li class="list__item" id="q3j53s_77"><p><span id="q3j53s_82"><b>SRP</b></span> &mdash; уточнение инкапсуляции: каждая капсула должна содержать одну ответственность.</p></li><li class="list__item" id="q3j53s_78"><p><span id="q3j53s_83"><b>OCP</b></span> &mdash; уточнение абстракции: расширяйте через новые реализации, а не меняйте старые.</p></li><li class="list__item" id="q3j53s_79"><p><span id="q3j53s_84"><b>LSP</b></span> &mdash; уточнение наследования: наследники не должны ломать поведение родителей.</p></li><li class="list__item" id="q3j53s_80"><p><span id="q3j53s_85"><b>ISP</b></span> &mdash; уточнение интерфейсов: делайте маленькие и специализированные интерфейсы.</p></li><li class="list__item" id="q3j53s_81"><p><span id="q3j53s_86"><b>DIP</b></span> &mdash; уточнение полиморфизма: связывайтесь через абстракции, а не через конкретные классы.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="q3j53s_75"><p>ООП даёт фундамент, SOLID &mdash; практические правила. Вместе они образуют устойчивый стиль проектирования.</p></aside></section></section><div class="last-modified">01 октября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="oop.html" class="navigation-links__prev">Объектно-ориентированное программирование</a><a href="aop.html" class="navigation-links__next">Аспектно-ориентированное программирование</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>