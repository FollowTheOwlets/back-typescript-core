<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:34.9209454"><title>Изменения в ES6 после ES5 | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"-uzq1d7_2","level":0,"title":"Введение","anchor":"#-uzq1d7_2"},{"id":"-uzq1d7_3","level":0,"title":"Новые возможности объявления переменных","anchor":"#-uzq1d7_3"},{"id":"-uzq1d7_4","level":0,"title":"Стрелочные функции","anchor":"#-uzq1d7_4"},{"id":"-uzq1d7_5","level":0,"title":"Шаблонные строки","anchor":"#-uzq1d7_5"},{"id":"-uzq1d7_6","level":0,"title":"Деструктуризация","anchor":"#-uzq1d7_6"},{"id":"-uzq1d7_7","level":0,"title":"Оператор распространения (Spread) и Rest","anchor":"#-uzq1d7_7"},{"id":"-uzq1d7_8","level":0,"title":"Классы","anchor":"#-uzq1d7_8"},{"id":"-uzq1d7_9","level":0,"title":"Модули","anchor":"#-uzq1d7_9"},{"id":"-uzq1d7_10","level":0,"title":"Заключение","anchor":"#-uzq1d7_10"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Изменения в ES6 после ES5 | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/es6.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Изменения в ES6 после ES5 | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/es6.html#webpage",
    "url": "writerside-documentation//1.0.0/es6.html",
    "name": "Изменения в ES6 после ES5 | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="ES6" data-main-title="Изменения в ES6 после ES5" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_JavaScript.topic|JavaScript"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ES6" id="ES6.topic">Изменения в ES6 после ES5</h1><section class="chapter"><h2 id="-uzq1d7_2" data-toc="-uzq1d7_2">Введение</h2><p id="-uzq1d7_11">С выходом <span class="tooltip" id="-uzq1d7_13" title="Версия стандарта ECMAScript 2015, значительно расширившая возможности JavaScript">ECMAScript 2015</span> язык <span class="tooltip" id="-uzq1d7_14" title="Язык программирования, используемый для создания веб-приложений">JavaScript</span> получил множество новых возможностей, которые значительно расширили его применение в разработке, в том числе на стороне сервера. Эти изменения упростили написание кода, сделали его более читаемым и приблизили язык к современным стандартам промышленной разработки.</p><aside class="prompt" data-type="note" data-title="" id="-uzq1d7_12"><p>ES6 стал переломным моментом, после которого JavaScript окончательно укрепился не только как язык для браузеров, но и как основа для <span class="tooltip" id="-uzq1d7_15" title="Часть приложения, выполняющая обработку данных на стороне сервера">серверных приложений</span>, например, через платформу Node.js.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_3" data-toc="-uzq1d7_3">Новые возможности объявления переменных</h2><p id="-uzq1d7_16">В ES5 существовало только ключевое слово <code class="code" id="-uzq1d7_20">var</code>, которое имело проблемы с областью видимости. В ES6 добавлены новые способы:</p><ul class="list _bullet" id="-uzq1d7_17"><li class="list__item" id="-uzq1d7_21"><p><code class="code" id="-uzq1d7_23">let</code> &mdash; переменные с блочной областью видимости.</p></li><li class="list__item" id="-uzq1d7_22"><p><code class="code" id="-uzq1d7_24">const</code> &mdash; переменные-константы, значение которых нельзя переопределить.</p></li></ul><div class="code-block" data-lang="javascript">
      // Пример использования let и const
      let count = 10;
      const PI = 3.14;

      if (true) {
          let inner = &quot;hello&quot;;
          console.log(inner); // hello
      }
      // console.log(inner); // Ошибка, переменная недоступна
    </div><aside class="prompt" data-type="warning" data-title="" id="-uzq1d7_19"><p>Использование <code class="code" id="-uzq1d7_25">var</code> может привести к трудноуловимым ошибкам из-за всплытия переменных (hoisting). Для серверного кода предпочтительно использовать <code class="code" id="-uzq1d7_26">let</code> и <code class="code" id="-uzq1d7_27">const</code>.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_4" data-toc="-uzq1d7_4">Стрелочные функции</h2><p id="-uzq1d7_28">ES6 ввёл <span class="tooltip" id="-uzq1d7_31" title="Короткий синтаксис объявления функции с лексическим this и без собственного arguments/prototype.">стрелочные функции</span>, которые являются сокращённой формой записи функций и наследуют <code class="code" id="-uzq1d7_32">this</code> из внешнего контекста.</p><div class="code-block" data-lang="javascript">
      // Обычная функция
      function sum(a, b) {
          return a + b;
      }

      // Стрелочная функция
      const sumArrow = (a, b) =&gt; a + b;

      console.log(sum(2, 3));      // 5
      console.log(sumArrow(2, 3)); // 5
    </div><aside class="prompt" data-type="note" data-title="" id="-uzq1d7_30"><p>Стрелочные функции особенно полезны при работе с методами массивов (<code class="code" id="-uzq1d7_33">map</code>, <code class="code" id="-uzq1d7_34">filter</code>, <code class="code" id="-uzq1d7_35">reduce</code>), где важно сохранить контекст.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_5" data-toc="-uzq1d7_5">Шаблонные строки</h2><p id="-uzq1d7_36">В ES6 появились <span class="tooltip" id="-uzq1d7_39" title="Строки в обратных кавычках с поддержкой подстановки выражений">шаблонные строки</span>, которые упрощают работу со строками и позволяют использовать выражения внутри строки.</p><div class="code-block" data-lang="javascript">
      const name = &quot;Alex&quot;;
      const age = 25;
      console.log(`Имя: ${name}, Возраст: ${age}`);
      // Имя: Alex, Возраст: 25
    </div><aside class="prompt" data-type="note" data-title="" id="-uzq1d7_38"><p>Такой синтаксис особенно удобен для формирования сообщений и логов на сервере, где требуется выводить динамическую информацию.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_6" data-toc="-uzq1d7_6">Деструктуризация</h2><p id="-uzq1d7_40">ES6 позволяет извлекать значения из массивов и объектов с помощью <span class="tooltip" id="-uzq1d7_43" title="Синтаксис извлечения значений из объектов и массивов">деструктуризации</span>.</p><div class="code-block" data-lang="javascript">
      const user = {id: 1, name: &quot;Ivan&quot;};
      const {id, name} = user;
      console.log(id);   // 1
      console.log(name); // Ivan

      const arr = [10, 20, 30];
      const [first, second] = arr;
      console.log(first, second); // 10 20
    </div><aside class="prompt" data-type="tip" data-title="" id="-uzq1d7_42"><p>Деструктуризация делает код более компактным и читабельным, особенно при работе с <span class="tooltip" id="-uzq1d7_44" title="Data Transfer Object — объект для передачи данных между слоями приложения">DTO</span> и объектами конфигураций.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_7" data-toc="-uzq1d7_7">Оператор распространения (Spread) и Rest</h2><p id="-uzq1d7_45">ES6 добавил синтаксис <code class="code" id="-uzq1d7_48">...</code>, который может использоваться для объединения или копирования массивов и объектов.</p><div class="code-block" data-lang="javascript">
      const arr1 = [1, 2, 3];
      const arr2 = [...arr1, 4, 5];
      console.log(arr2); // [1, 2, 3, 4, 5]

      function sum(...numbers) {
          return numbers.reduce((a, b) =&gt; a + b, 0);
      }

      console.log(sum(1, 2, 3)); // 6
    </div><aside class="prompt" data-type="note" data-title="" id="-uzq1d7_47"><p>Эти возможности часто используются в Node.js для обработки параметров функций и объединения данных из разных источников.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_8" data-toc="-uzq1d7_8">Классы</h2><p id="-uzq1d7_49">В ES6 появились <span class="tooltip" id="-uzq1d7_52" title="Синтаксическая надстройка над прототипным наследованием, введённая в ES6">классы</span> &mdash; синтаксический сахар над прототипным наследованием.</p><div class="code-block" data-lang="javascript">
      class User {
          constructor(name) {
              this.name = name;
          }

          sayHello() {
              console.log(`Привет, я ${this.name}`);
          }
      }

      const user = new User(&quot;Alex&quot;);
      user.sayHello(); // Привет, я Alex
    </div><aside class="prompt" data-type="note" data-title="" id="-uzq1d7_51"><p>Использование классов облегчает переход к объектно-ориентированным принципам и делает код более структурированным, что особенно полезно в больших проектах на Backend.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_9" data-toc="-uzq1d7_9">Модули</h2><p id="-uzq1d7_53">ES6 ввёл <span class="tooltip" id="-uzq1d7_56" title="Изолированный фрагмент кода, который можно импортировать и экспортировать">модули</span> с ключевыми словами <code class="code" id="-uzq1d7_57">import</code> и <code class="code" id="-uzq1d7_58">export</code>.</p><div class="code-block" data-lang="javascript">
      // user.js
      export class User {
          constructor(name) {
              this.name = name;
          }
      }

      // app.js
      import {User} from &quot;./user.js&quot;;

      const user = new User(&quot;Ivan&quot;);
    </div><aside class="prompt" data-type="warning" data-title="" id="-uzq1d7_55"><p>В Node.js изначально поддерживалась система модулей CommonJS (<code class="code" id="-uzq1d7_59">require</code>/<code class="code" id="-uzq1d7_60">module.exports</code>), но современные версии Node.js уже поддерживают ES-модули. Важно выбрать одну систему и придерживаться её в проекте.</p></aside></section><section class="chapter"><h2 id="-uzq1d7_10" data-toc="-uzq1d7_10">Заключение</h2><p id="-uzq1d7_61">ES6 принесло множество улучшений, которые сделали JavaScript мощным инструментом для создания серверных приложений. Новые возможности позволяют писать более надёжный, структурированный и читаемый код.</p></section><div class="last-modified">24 сентября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="arraystringjs.html" class="navigation-links__prev">Методы массивов и строк в JavaScript</a><a href="classes.html" class="navigation-links__next">Классы</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>