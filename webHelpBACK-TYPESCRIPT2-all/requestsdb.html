<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:34.9472191"><title>Запросы и их анализ | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"w8xjcf_3","level":0,"title":"Работа запросов","anchor":"#w8xjcf_3"},{"id":"w8xjcf_4","level":0,"title":"Подготовленный оператор","anchor":"#w8xjcf_4"},{"id":"sql","level":0,"title":"Курсоры в SQL","anchor":"#sql"},{"id":"w8xjcf_6","level":0,"title":"Анализ запросов","anchor":"#w8xjcf_6"},{"id":"postgresql","level":0,"title":"Создание индексов в PostgreSQL","anchor":"#postgresql"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Запросы и их анализ | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/requestsdb.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Запросы и их анализ | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/requestsdb.html#webpage",
    "url": "writerside-documentation//1.0.0/requestsdb.html",
    "name": "Запросы и их анализ | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="RequestsDB" data-main-title="Запросы и их анализ" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_Data.topic|Хранение данных///SQL.md|SQL"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="RequestsDB" id="RequestsDB.md">Запросы и их анализ</h1><section class="chapter"><h2 id="w8xjcf_3" data-toc="w8xjcf_3">Работа запросов</h2><figure id="w8xjcf_8"><img alt="sql_1.png" src="images/sql_1.png" title="sql_1.png" width="892" height="506"></figure></section><section class="chapter"><h2 id="w8xjcf_4" data-toc="w8xjcf_4">Подготовленный оператор</h2><section class="chapter"><h3 id="w8xjcf_9" data-toc="w8xjcf_9">Пример запроса</h3><p id="w8xjcf_15">Если у нас есть запрос, например, с несколькими таблицами и условиями, подготовленный оператор будет полезен:</p><div class="code-block" data-lang="sql">
SELECT o.id, o.order_date, c.name, SUM(oi.quantity * oi.price) AS total_amount
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN order_items oi ON o.id = oi.order_id
WHERE o.customer_id = ? AND o.order_date BETWEEN ? AND ?
GROUP BY o.id, o.order_date, c.name
</div></section><section class="chapter"><h3 id="w8xjcf_10" data-toc="w8xjcf_10">Пример создания подготовленного оператора</h3><div class="code-block" data-lang="sql">
PREPARE get_order_summary (INT, DATE, DATE) AS
SELECT 
    o.id,
    o.order_date,
    c.name,
    SUM(oi.quantity * oi.price) AS total_amount
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN order_items oi ON o.id = oi.order_id
WHERE o.customer_id = $1 AND o.order_date BETWEEN $2 AND $3
GROUP BY o.id, o.order_date, c.name;

</div><p id="w8xjcf_18">В Java это будет выглядеть так:</p><div class="code-block" data-lang="java">
String query = &quot;SELECT o.id, o.order_date, c.name, SUM(oi.quantity * oi.price) AS total_amount &quot; +
               &quot;FROM orders o &quot; +
               &quot;JOIN customers c ON o.customer_id = c.id &quot; +
               &quot;JOIN order_items oi ON o.id = oi.order_id &quot; +
               &quot;WHERE o.customer_id = ? AND o.order_date BETWEEN ? AND ? &quot; +
               &quot;GROUP BY o.id, o.order_date, c.name&quot;;

PreparedStatement pstmt = conn.prepareStatement(query);

int customerId = 123;
Date startDate = new Date(2022, 1, 1);
Date endDate = new Date(2022, 12, 31);

pstmt.setInt(1, customerId);
pstmt.setDate(2, startDate);
pstmt.setDate(3, endDate);

ResultSet rs = pstmt.executeQuery();
</div></section><section class="chapter"><h3 id="w8xjcf_11" data-toc="w8xjcf_11">Преимущества подготовленных операторов</h3><ol class="list _decimal" id="w8xjcf_20" type="1"><li class="list__item" id="w8xjcf_21"><p id="w8xjcf_24"><span class="control" id="w8xjcf_25">Производительность</span>: Подготовленные операторы выполняются быстрее, так как сервер базы данных компилирует запрос один раз и может повторно использовать план выполнения.</p></li><li class="list__item" id="w8xjcf_22"><p id="w8xjcf_26"><span class="control" id="w8xjcf_27">Безопасность</span>: Защищают от SQL-инъекций, поскольку параметры передаются отдельно от SQL-кода.</p></li><li class="list__item" id="w8xjcf_23"><p id="w8xjcf_28"><span class="control" id="w8xjcf_29">Удобство</span>: Легко использовать переменные для передачи данных в запрос.</p></li></ol></section><section class="chapter"><h3 id="w8xjcf_12" data-toc="w8xjcf_12">Недостатки подготовленных операторов</h3><ol class="list _decimal" id="w8xjcf_30" type="1"><li class="list__item" id="w8xjcf_31"><p id="w8xjcf_33"><span class="control" id="w8xjcf_34">Сложность</span>: Может быть сложнее в реализации для очень простых запросов.</p></li><li class="list__item" id="w8xjcf_32"><p id="w8xjcf_35"><span class="control" id="w8xjcf_36">Ограничения</span>: Не все типы запросов могут быть подготовлены (например, запросы с динамическими таблицами или столбцами).</p></li></ol></section><section class="chapter"><h3 id="w8xjcf_13" data-toc="w8xjcf_13">Когда использовать подготовленные операторы?</h3><ul class="list _bullet" id="w8xjcf_37"><li class="list__item" id="w8xjcf_38"><p id="w8xjcf_41"><span class="control" id="w8xjcf_42">Повторное выполнение запросов</span>: Если один и тот же запрос выполняется многократно с разными параметрами.</p></li><li class="list__item" id="w8xjcf_39"><p id="w8xjcf_43"><span class="control" id="w8xjcf_44">Сложные запросы</span>: Для запросов с несколькими таблицами или условиями.</p></li><li class="list__item" id="w8xjcf_40"><p id="w8xjcf_45"><span class="control" id="w8xjcf_46">Безопасность</span>: Для защиты от SQL-инъекций.</p></li></ul></section><section class="chapter"><h3 id="w8xjcf_14" data-toc="w8xjcf_14">Когда не стоит использовать подготовленные операторы?</h3><ul class="list _bullet" id="w8xjcf_47"><li class="list__item" id="w8xjcf_48"><p id="w8xjcf_50"><span class="control" id="w8xjcf_51">Простые запросы</span>: Если запрос очень простой и выполняется только один раз.</p></li><li class="list__item" id="w8xjcf_49"><p id="w8xjcf_52"><span class="control" id="w8xjcf_53">Динамические запросы</span>: Если структура запроса меняется динамически.</p></li></ul></section></section><section class="chapter"><h2 id="sql" data-toc="sql">Курсоры в SQL</h2><p id="w8xjcf_54">Курсор &mdash; это механизм, который позволяет обрабатывать результаты запроса по одной строке за раз. Это особенно полезно, когда необходимо выполнить сложные операции над каждой строкой или когда приложение не может эффективно обрабатывать весь результирующий набор сразу.</p><section class="chapter"><h3 id="w8xjcf_55" data-toc="w8xjcf_55">Основные операции с курсорами</h3><ol class="list _decimal" id="w8xjcf_61" type="1"><li class="list__item" id="w8xjcf_62"><p id="w8xjcf_67"><span class="control" id="w8xjcf_69">Объявление курсора</span>: Определяется запрос, который будет использоваться для получения данных.</p><div class="code-block" data-lang="sql">
DECLARE my_cursor CURSOR FOR SELECT * FROM my_table;
</div></li><li class="list__item" id="w8xjcf_63"><p id="w8xjcf_70"><span class="control" id="w8xjcf_72">Открытие курсора</span>: Курсор открывается, и выполняется запрос для получения данных.</p><div class="code-block" data-lang="sql">
OPEN my_cursor;
</div></li><li class="list__item" id="w8xjcf_64"><p id="w8xjcf_73"><span class="control" id="w8xjcf_75">Извлечение данных</span>: Используется оператор <code class="code" id="w8xjcf_76">FETCH</code> для получения данных по одной строке за раз.</p><div class="code-block" data-lang="sql">
FETCH FROM my_cursor INTO @variable;
</div></li><li class="list__item" id="w8xjcf_65"><p id="w8xjcf_77"><span class="control" id="w8xjcf_79">Закрытие курсора</span>: После обработки всех данных курсор закрывается.</p><div class="code-block" data-lang="sql">
CLOSE my_cursor;
</div></li><li class="list__item" id="w8xjcf_66"><p id="w8xjcf_80"><span class="control" id="w8xjcf_82">Освобождение ресурсов</span>: Курсор удаляется, чтобы освободить ресурсы.</p><div class="code-block" data-lang="sql">
DEALLOCATE my_cursor;
</div></li></ol></section><section class="chapter"><h3 id="w8xjcf_56" data-toc="w8xjcf_56">Преимущества курсоров</h3><ol class="list _decimal" id="w8xjcf_83" type="1"><li class="list__item" id="w8xjcf_84"><p id="w8xjcf_87"><span class="control" id="w8xjcf_88">Последовательная обработка</span>: Позволяет обрабатывать данные по одной строке за раз, что полезно для сложных вычислений или обновлений.</p></li><li class="list__item" id="w8xjcf_85"><p id="w8xjcf_89"><span class="control" id="w8xjcf_90">Эффективность</span>: Снижает нагрузку на систему, так как не требует загрузки всего результирующего набора в память.</p></li><li class="list__item" id="w8xjcf_86"><p id="w8xjcf_91"><span class="control" id="w8xjcf_92">Удобство</span>: Легко интегрируется с языками программирования, позволяя использовать данные в циклах и других структурах.</p></li></ol></section><section class="chapter"><h3 id="w8xjcf_57" data-toc="w8xjcf_57">Типы курсоров</h3><ul class="list _bullet" id="w8xjcf_93"><li class="list__item" id="w8xjcf_94"><p id="w8xjcf_98"><span class="control" id="w8xjcf_99">Статические</span>: Создаются в виде временной таблицы и не отражают изменения данных после открытия.</p></li><li class="list__item" id="w8xjcf_95"><p id="w8xjcf_100"><span class="control" id="w8xjcf_101">Динамические</span>: Отражают все изменения в данных во время работы.</p></li><li class="list__item" id="w8xjcf_96"><p id="w8xjcf_102"><span class="control" id="w8xjcf_103">Последовательные</span>: Позволяют перемещаться только в прямом направлении.</p></li><li class="list__item" id="w8xjcf_97"><p id="w8xjcf_104"><span class="control" id="w8xjcf_105">Прокручиваемые</span>: Позволяют перемещаться в обоих направлениях.</p></li></ul></section><section class="chapter"><h3 id="w8xjcf_58" data-toc="w8xjcf_58">Пример использования курсора</h3><div class="code-block" data-lang="sql">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class CursorExample {
    public static void main(String[] args) {
        // Установка соединения с базой данных
        String url = &quot;jdbc:mysql://localhost:3306/mydatabase&quot;;
        String username = &quot;myuser&quot;;
        String password = &quot;mypassword&quot;;

        try (Connection conn = DriverManager.getConnection(url, username, password)) {
            // Создание оператора
            Statement stmt = conn.createStatement();

            // Выполнение запроса
            String query = &quot;SELECT id, name FROM users&quot;;
            ResultSet rs = stmt.executeQuery(query);

            // Обработка результатов
            while (rs.next()) {
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);

                // Обработка данных
                System.out.println(&quot;ID: &quot; + id + &quot;, Name: &quot; + name);
            }
        } catch (SQLException e) {
            System.out.println(&quot;Ошибка: &quot; + e.getMessage());
        }
    }
}
</div></section><section class="chapter"><h3 id="w8xjcf_59" data-toc="w8xjcf_59">Когда использовать курсоры?</h3><ul class="list _bullet" id="w8xjcf_107"><li class="list__item" id="w8xjcf_108"><p id="w8xjcf_111"><span class="control" id="w8xjcf_112">Сложные вычисления</span>: Когда необходимо выполнить сложные операции над каждой строкой.</p></li><li class="list__item" id="w8xjcf_109"><p id="w8xjcf_113"><span class="control" id="w8xjcf_114">Обновления данных</span>: При точном обновлении данных, когда необходимо обрабатывать каждую строку индивидуально.</p></li><li class="list__item" id="w8xjcf_110"><p id="w8xjcf_115"><span class="control" id="w8xjcf_116">Ограниченные ресурсы</span>: Когда приложение не может эффективно обрабатывать весь результирующий набор сразу.</p></li></ul></section><section class="chapter"><h3 id="w8xjcf_60" data-toc="w8xjcf_60">Когда не стоит использовать курсоры?</h3><ul class="list _bullet" id="w8xjcf_117"><li class="list__item" id="w8xjcf_118"><p id="w8xjcf_120"><span class="control" id="w8xjcf_121">Простые запросы</span>: Для простых запросов, где можно использовать обычные SQL-операторы.</p></li><li class="list__item" id="w8xjcf_119"><p id="w8xjcf_122"><span class="control" id="w8xjcf_123">Большие объемы данных</span>: Если необходимо обработать очень большой объем данных, может быть более эффективно использовать другие методы, такие как параллельная обработка или обработка в пакетах.</p></li></ul></section></section><section class="chapter"><h2 id="w8xjcf_6" data-toc="w8xjcf_6">Анализ запросов</h2><section class="chapter"><h3 id="w8xjcf_124" data-toc="w8xjcf_124">Этапы анализа запросов</h3><ol class="list _decimal" id="w8xjcf_128" type="1"><li class="list__item" id="w8xjcf_129"><p id="w8xjcf_134"><span class="control" id="w8xjcf_135">Синтаксический анализ</span>: Проверка запроса на соответствие синтаксису SQL.</p></li><li class="list__item" id="w8xjcf_130"><p id="w8xjcf_136"><span class="control" id="w8xjcf_137">Разрешение представлений и верификация</span>: Проверка доступа к таблицам и полям.</p></li><li class="list__item" id="w8xjcf_131"><p id="w8xjcf_138"><span class="control" id="w8xjcf_139">Генерация логического плана</span>: Определение шагов, которые необходимо выполнить для получения результатов.</p></li><li class="list__item" id="w8xjcf_132"><p id="w8xjcf_140"><span class="control" id="w8xjcf_141">Оптимизация запроса</span>: Выбор наиболее эффективного плана выполнения на основе статистики базы данных.</p></li><li class="list__item" id="w8xjcf_133"><p id="w8xjcf_142"><span class="control" id="w8xjcf_143">Генерация физического плана</span>: Определение конкретных операций, которые будут выполнены (например, сканирование таблицы или использование индекса).</p></li></ol></section><section class="chapter"><h3 id="w8xjcf_125" data-toc="w8xjcf_125">Инструменты для анализа запросов</h3><ol class="list _decimal" id="w8xjcf_144" type="1"><li class="list__item" id="w8xjcf_145"><p id="w8xjcf_147"><span class="control" id="w8xjcf_149">EXPLAIN и EXPLAIN ANALYZE</span>: Используются для получения плана выполнения запроса и анализа его производительности.</p><div class="code-block" data-lang="sql">
EXPLAIN SELECT * FROM my_table WHERE condition;
EXPLAIN ANALYZE SELECT * FROM my_table WHERE condition;
</div></li><li class="list__item" id="w8xjcf_146"><p id="w8xjcf_150"><span class="control" id="w8xjcf_152">Профилировщики запросов</span>: Инструменты типа <code class="code" id="w8xjcf_153">pt-query-digest</code> для MySQL или <code class="code" id="w8xjcf_154">pg_stat_statements</code> для PostgreSQL помогают анализировать производительность запросов и выявлять медленные запросы.</p><div class="code-block" data-lang="sql">
-- PostgreSQL
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
</div></li></ol></section><section class="chapter"><h3 id="w8xjcf_126" data-toc="w8xjcf_126">Анализ плана выполнения</h3><p id="w8xjcf_155">При анализе плана выполнения запроса следует обратить внимание на следующие аспекты:</p><ul class="list _bullet" id="w8xjcf_156"><li class="list__item" id="w8xjcf_157"><p id="w8xjcf_161"><span class="control" id="w8xjcf_162">Тип сканирования</span>: Seq Scan (полное сканирование таблицы), Index Scan (использование индекса), Bitmap Heap Scan (использование битовой карты индекса).</p></li><li class="list__item" id="w8xjcf_158"><p id="w8xjcf_163"><span class="control" id="w8xjcf_164">Использование индексов</span>: Index Only Scan (все данные получены из индекса) или Index Scan (дополнительное чтение таблицы).</p></li><li class="list__item" id="w8xjcf_159"><p id="w8xjcf_165"><span class="control" id="w8xjcf_166">Объединения таблиц</span>: Nested Loop Join, Hash Join, Merge Join.</p></li><li class="list__item" id="w8xjcf_160"><p id="w8xjcf_167"><span class="control" id="w8xjcf_168">Операции сортировки и группировки</span>: Sort, Group By.</p></li></ul></section><section class="chapter"><h3 id="w8xjcf_127" data-toc="w8xjcf_127">Пример анализа плана выполнения</h3><div class="code-block" data-lang="sql">
EXPLAIN ANALYZE
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.order_date BETWEEN '2022-01-01' AND '2022-12-31';
</div><p id="w8xjcf_170">Результат анализа может выглядеть примерно так:</p><div class="code-block" data-lang="none">
Nested Loop  (cost=0.00..10.70 rows=100 width=268)
  -&gt; Seq Scan on orders o  (cost=0.00..5.10 rows=50 width=136)
        Filter: (order_date &gt;= '2022-01-01'::date) AND (order_date  Index Scan using customers_pkey on customers c  (cost=0.00..0.20 rows=1 width=132)
        Index Cond: (id = o.customer_id)
</div><p id="w8xjcf_172">В этом примере используется полное сканирование таблицы <code class="code" id="w8xjcf_173">orders</code> и индексное сканирование таблицы <code class="code" id="w8xjcf_174">customers</code>.</p></section></section><section class="chapter"><h2 id="postgresql" data-toc="postgresql">Создание индексов в PostgreSQL</h2><p id="w8xjcf_175"><span class="control" id="w8xjcf_182">Важно понимать, что хаотичное добавление данных в таблицу по которой настроен индекс, может быть очень дорогим по времени</span></p><section class="chapter"><h3 id="w8xjcf_176" data-toc="w8xjcf_176">Основные команды</h3><p id="w8xjcf_183">Индекс в PostgreSQL создается с помощью команды <code class="code" id="w8xjcf_187">CREATE INDEX</code>. Основной синтаксис:</p><div class="code-block" data-lang="sql">
CREATE INDEX имя_индекса ON таблица (столбец);
</div><p id="w8xjcf_185">Например:</p><div class="code-block" data-lang="sql">
CREATE INDEX idx_name ON users (name);
</div></section><section class="chapter"><h3 id="w8xjcf_177" data-toc="w8xjcf_177">Типы индексов</h3><p id="w8xjcf_188">PostgreSQL поддерживает несколько типов индексов:</p><ul class="list _bullet" id="w8xjcf_189"><li class="list__item" id="w8xjcf_190"><p id="w8xjcf_196"><span class="control" id="w8xjcf_197">B-Tree</span>: Подходит для большинства случаев, особенно для равных сравнений и диапазонов.</p></li><li class="list__item" id="w8xjcf_191"><p id="w8xjcf_198"><span class="control" id="w8xjcf_199">Hash</span>: Быстрее для равных сравнений, но требует больше места.</p></li><li class="list__item" id="w8xjcf_192"><p id="w8xjcf_200"><span class="control" id="w8xjcf_201">GiST</span>: Используется для геопространственных данных и некоторых типов данных, таких как массивы.</p></li><li class="list__item" id="w8xjcf_193"><p id="w8xjcf_202"><span class="control" id="w8xjcf_203">GIN</span>: Оптимально подходит для поиска элементов в массивах.</p></li><li class="list__item" id="w8xjcf_194"><p id="w8xjcf_204"><span class="control" id="w8xjcf_205">SP-GiST</span>: Используется для данных с пространственной структурой.</p></li><li class="list__item" id="w8xjcf_195"><p id="w8xjcf_206"><span class="control" id="w8xjcf_207">BRIN</span>: Быстрый и компактный индекс для больших таблиц с последовательными данными.</p></li></ul></section><section class="chapter"><h3 id="w8xjcf_178" data-toc="w8xjcf_178">Примеры создания индексов</h3><section class="chapter"><h4 id="1" data-toc="1">1. Простой индекс</h4><div class="code-block" data-lang="sql">
CREATE INDEX idx_name ON users (name);
</div></section><section class="chapter"><h4 id="2" data-toc="2">2. Уникальный индекс</h4><div class="code-block" data-lang="sql">
CREATE UNIQUE INDEX idx_email ON users (email);
</div></section><section class="chapter"><h4 id="3" data-toc="3">3. Составной индекс</h4><div class="code-block" data-lang="sql">
CREATE INDEX idx_name_email ON users (name, email);
</div></section><section class="chapter"><h4 id="4" data-toc="4">4. Индекс по выражению</h4><div class="code-block" data-lang="sql">
CREATE INDEX idx_upper_name ON users (upper(name));
</div></section><section class="chapter"><h4 id="5" data-toc="5">5. Неблокирующее создание индекса</h4><div class="code-block" data-lang="sql">
CREATE INDEX idx_name ON users (name) CONCURRENTLY;
</div><p id="w8xjcf_218">Этот метод позволяет создавать индекс без блокировки таблицы, что полезно для больших таблиц.</p></section></section><section class="chapter"><h3 id="w8xjcf_179" data-toc="w8xjcf_179">Определение необходимости индекса</h3><p id="w8xjcf_219">Чтобы понять, какой индекс нужен для запроса, следует проанализировать план выполнения запроса с помощью команды <code class="code" id="w8xjcf_222">EXPLAIN</code> или <code class="code" id="w8xjcf_223">EXPLAIN ANALYZE</code>.</p><div class="code-block" data-lang="sql">
EXPLAIN SELECT * FROM users WHERE name = 'John Doe';
</div><p id="w8xjcf_221">Если в плане выполнения используется полное сканирование таблицы (<code class="code" id="w8xjcf_224">Seq Scan</code>), это может указывать на необходимость индекса.</p></section><section class="chapter"><h3 id="w8xjcf_180" data-toc="w8xjcf_180">Селективность индекса</h3><p id="w8xjcf_225">Селективность индекса &mdash; это мера того, насколько хорошо индекс может сузить количество строк, которые необходимо просмотреть. Хороший индекс должен иметь высокую селективность.</p></section><section class="chapter"><h3 id="w8xjcf_181" data-toc="w8xjcf_181">Как правильно создать индекс</h3><p id="w8xjcf_226">Пример запроса:</p><div class="code-block" data-lang="sql">
SELECT * FROM users
    WHERE gender = 'male'
        AND country = 'USA'
        AND name = 'Lev'
        AND age &gt; 18
        AND salary &gt; 500000;
</div><p id="w8xjcf_228">Грамотный индекс будет выглядеть следующим образом:</p><div class="code-block" data-lang="sql">
CREATE INDEX idx_users_country_name_age
    ON users (country, name, age);
</div><p id="w8xjcf_230"><span class="control" id="w8xjcf_233">Потому что gender плохо селективное поле, а между age и salary надо выбрать так, чтобы вариантов значений было как можно больше.</span></p><section class="chapter"><h4 id="w8xjcf_231" data-toc="w8xjcf_231">Факторы, влияющие на селективность:</h4><ul class="list _bullet" id="w8xjcf_234"><li class="list__item" id="w8xjcf_235"><p id="w8xjcf_238"><span class="control" id="w8xjcf_239">Уникальность данных</span>: Если столбец содержит уникальные значения, индекс будет более эффективным.</p></li><li class="list__item" id="w8xjcf_236"><p id="w8xjcf_240"><span class="control" id="w8xjcf_241">Распределение данных</span>: Если данные распределены равномерно, индекс будет более эффективным.</p></li><li class="list__item" id="w8xjcf_237"><p id="w8xjcf_242"><span class="control" id="w8xjcf_243">Частота использования</span>: Если запрос часто выполняется, индекс будет более оправдан.</p></li></ul></section><section class="chapter"><h4 id="w8xjcf_232" data-toc="w8xjcf_232">Как оценить селективность:</h4><ol class="list _decimal" id="w8xjcf_244" type="1"><li class="list__item" id="w8xjcf_245"><p id="w8xjcf_248"><span class="control" id="w8xjcf_249">Используйте команду <code class="code" id="w8xjcf_250">EXPLAIN</code></span>: Анализируйте план выполнения запроса, чтобы увидеть, использует ли PostgreSQL индекс.</p></li><li class="list__item" id="w8xjcf_246"><p id="w8xjcf_251"><span class="control" id="w8xjcf_252">Проверьте статистику индекса</span>: Используйте команды типа <code class="code" id="w8xjcf_253">pg_stat_user_indexes</code> для оценки использования индекса.</p></li><li class="list__item" id="w8xjcf_247"><p id="w8xjcf_254"><span class="control" id="w8xjcf_255">Оцените распределение данных</span>: Используйте команды типа <code class="code" id="w8xjcf_256">SELECT COUNT(DISTINCT column_name) FROM table_name</code> для оценки уникальности данных.</p></li></ol></section></section></section><div class="last-modified">13 марта 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="db-theory.html" class="navigation-links__prev">Теория (Н, Т, Д)</a><a href="nosql.html" class="navigation-links__next">NO SQL</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>