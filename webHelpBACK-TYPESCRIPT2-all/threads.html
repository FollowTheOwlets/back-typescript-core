<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:34.9249476"><title>Многопоточность в JS | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"-o0hwx6_3","level":0,"title":"Зачем многопоточность в Node.js","anchor":"#-o0hwx6_3"},{"id":"-o0hwx6_4","level":0,"title":"Архитектура: Event Loop, libuv и Worker","anchor":"#-o0hwx6_4"},{"id":"-o0hwx6_5","level":0,"title":"Когда выбирать worker_threads, а когда нет","anchor":"#-o0hwx6_5"},{"id":"-o0hwx6_6","level":0,"title":"API: базовые сущности и каналы связи","anchor":"#-o0hwx6_6"},{"id":"-o0hwx6_7","level":0,"title":"Пример 1: простой воркер (два файла)","anchor":"#-o0hwx6_7"},{"id":"-o0hwx6_8","level":0,"title":"Пример 2: воркер как отдельный модуль (многофайловый)","anchor":"#-o0hwx6_8"},{"id":"-o0hwx6_9","level":0,"title":"Пример 3: простой пул воркеров (переиспользование потоков)","anchor":"#-o0hwx6_9"},{"id":"-o0hwx6_10","level":0,"title":"Передача данных: Structured Clone, Transferable, SharedArrayBuffer","anchor":"#-o0hwx6_10"},{"id":"-o0hwx6_11","level":0,"title":"Двусторонние каналы: MessageChannel/MessagePort","anchor":"#-o0hwx6_11"},{"id":"-o0hwx6_12","level":0,"title":"Отмена задач и таймауты","anchor":"#-o0hwx6_12"},{"id":"-o0hwx6_13","level":0,"title":"ESM, TypeScript и бандлинг","anchor":"#-o0hwx6_13"},{"id":"-o0hwx6_14","level":0,"title":"Ошибки, выход, утечки","anchor":"#-o0hwx6_14"},{"id":"-o0hwx6_15","level":0,"title":"Производительность: измеряем и считаем","anchor":"#-o0hwx6_15"},{"id":"-o0hwx6_16","level":0,"title":"Расширенный многофайловый пример: обработка изображений в пуле","anchor":"#-o0hwx6_16"},{"id":"-o0hwx6_17","level":0,"title":"Чеклист лучших практик","anchor":"#-o0hwx6_17"},{"id":"-o0hwx6_18","level":0,"title":"Типичные ошибки и подводные камни","anchor":"#-o0hwx6_18"},{"id":"-o0hwx6_19","level":0,"title":"Сравнение: worker_threads vs child_process vs cluster","anchor":"#-o0hwx6_19"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Многопоточность в JS | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/threads.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Многопоточность в JS | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/threads.html#webpage",
    "url": "writerside-documentation//1.0.0/threads.html",
    "name": "Многопоточность в JS | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="Threads" data-main-title="Многопоточность в JS" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_JavaScript.topic|JavaScript"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Threads" id="Threads.topic">Многопоточность в JS</h1><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_2"><p id="-o0hwx6_20">❗❗❗Перед прочтением изучите теоретический материал про многопоточность❗❗❗</p></aside><section class="chapter"><h2 id="-o0hwx6_3" data-toc="-o0hwx6_3">Зачем многопоточность в Node.js</h2><p id="-o0hwx6_21">Node.js исторически опирается на однопоточный <span class="tooltip" id="-o0hwx6_23" title="Событийный цикл — механизм поэтапного исполнения задач и I/O"><code class="code" id="-o0hwx6_26">Event Loop</code></span> и неблокирующий ввод/вывод. Это идеально для сетевых приложений, но плохо для CPU-тяжёлых задач (парсинг больших файлов, криптография, сжатие, обработка изображений, ML-инференс). <span id="-o0hwx6_24"><b>Многопоточность</b></span> через модуль <span class="tooltip" id="-o0hwx6_25" title="Модуль Node.js для работы с потоками JavaScript"><code class="code" id="-o0hwx6_27">worker_threads</code></span> позволяет вынести такие расчёты в отдельные потоки, не блокируя главный цикл событий.</p><aside class="prompt" data-type="note" data-title="" id="-o0hwx6_22"><p id="-o0hwx6_28"><span id="-o0hwx6_29"><b>Ключевая идея:</b></span> JavaScript-код в Node по умолчанию выполняется в одном потоке. <span class="tooltip" id="-o0hwx6_30" title="Поток исполнения JavaScript с собственным Event Loop и изолятом V8"><code class="code" id="-o0hwx6_32">Worker</code></span> создаёт <span id="-o0hwx6_31"><b>ещё один</b></span> поток с отдельным JS-движком и собственным Event Loop.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_4" data-toc="-o0hwx6_4">Архитектура: Event Loop, libuv и Worker</h2><p id="-o0hwx6_33">Каждый <span class="tooltip" id="-o0hwx6_35" title="Изолированный контекст исполнения JavaScript в движке V8">изолят V8</span> исполняет JS и имеет свой <span class="tooltip" id="-o0hwx6_36" title="Событийный цикл — механизм поэтапного исполнения задач и I/O"><code class="code" id="-o0hwx6_40">Event Loop</code></span>. Node использует <span class="tooltip" id="-o0hwx6_37" title="Библиотека C для событийного цикла и неблокирующего I/O в Node.js"><code class="code" id="-o0hwx6_41">libuv</code></span> с внутренним <span class="tooltip" id="-o0hwx6_38" title="Набор заранее созданных потоков для выполнения задач без накладных расходов на создание"><code class="code" id="-o0hwx6_42">пулом потоков</code></span> для некоторых операций (fs, crypto), однако это не исполняет ваш JS параллельно. <span class="tooltip" id="-o0hwx6_39" title="Поток исполнения JavaScript с собственным Event Loop и изолятом V8"><code class="code" id="-o0hwx6_43">Worker</code></span> создаёт новый изолят и ОС-поток, где ваш JS действительно идёт параллельно.</p><aside class="prompt" data-type="tip" data-title="" id="-o0hwx6_34"><p id="-o0hwx6_44">Один процесс Node может содержать множество <span class="tooltip" id="-o0hwx6_45" title="Поток исполнения JavaScript с собственным Event Loop и изолятом V8">воркеров</span>, каждый со своей памятью и циклом событий.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_5" data-toc="-o0hwx6_5">Когда выбирать worker_threads, а когда нет</h2><ul class="list _bullet" id="-o0hwx6_46"><li class="list__item" id="-o0hwx6_48"><p><span id="-o0hwx6_52"><b>CPU-bound задачи</b></span>: изображения, видео, PDF, криптография, сложная сериализация &mdash; <span class="tooltip" id="-o0hwx6_53" title="Модуль Node.js для работы с потоками JavaScript"><code class="code" id="-o0hwx6_54">worker_threads</code></span>.</p></li><li class="list__item" id="-o0hwx6_49"><p><span id="-o0hwx6_55"><b>I/O-bound</b></span> (базы, HTTP, очереди) &mdash; чаще достаточно встроенного неблокирующего I/O.</p></li><li class="list__item" id="-o0hwx6_50"><p><span id="-o0hwx6_56"><b>Изоляция памяти и надёжность</b></span>: для недоверенного кода и &laquo;жёстких&raquo; перезапусков лучше <span class="tooltip" id="-o0hwx6_57" title="Модуль Node.js для запуска процессов-потомков"><code class="code" id="-o0hwx6_58">child_process</code></span> (отдельный процесс).</p></li><li class="list__item" id="-o0hwx6_51"><p><span id="-o0hwx6_59"><b>Масштабирование по ядрам</b></span>: распределение соединений по ядрам &mdash; <span class="tooltip" id="-o0hwx6_60" title="Модуль Node.js для форка нескольких процессов, разделяющих один порт"><code class="code" id="-o0hwx6_61">cluster</code></span> или несколько процессов за балансировщиком.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_47"><p id="-o0hwx6_62">Не используйте воркеры для каждой мелкой операции. Создание потока &mdash; дорогая операция. Объединяйте задачи в <span class="tooltip" id="-o0hwx6_63" title="Набор заранее созданных потоков для выполнения задач без накладных расходов на создание"><code class="code" id="-o0hwx6_64">пул</code></span> и переиспользуйте.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_6" data-toc="-o0hwx6_6">API: базовые сущности и каналы связи</h2><ul class="list _bullet" id="-o0hwx6_65"><li class="list__item" id="-o0hwx6_67"><p><span class="tooltip" id="-o0hwx6_74" title="Поток исполнения JavaScript с собственным Event Loop и изолятом V8"><code class="code" id="-o0hwx6_75">Worker</code></span> &mdash; класс для создания потока.</p></li><li class="list__item" id="-o0hwx6_68"><p><span class="tooltip" id="-o0hwx6_76" title="Флаг среды выполнения: находимся ли мы в главном потоке"><code class="code" id="-o0hwx6_77">isMainThread</code></span> &mdash; признак &laquo;мы в главном потоке?&raquo;.</p></li><li class="list__item" id="-o0hwx6_69"><p><span class="tooltip" id="-o0hwx6_78" title="Канал связи воркера с родительским потоком"><code class="code" id="-o0hwx6_79">parentPort</code></span> &mdash; порт связи с родителем (внутри воркера).</p></li><li class="list__item" id="-o0hwx6_70"><p><span class="tooltip" id="-o0hwx6_80" title="Набор данных, переданных воркеру при создании"><code class="code" id="-o0hwx6_81">workerData</code></span> &mdash; &laquo;снэпшот&raquo; входных данных при запуске воркера.</p></li><li class="list__item" id="-o0hwx6_71"><p><span class="tooltip" id="-o0hwx6_82" title="Пара связанных двунаправленных портов для обмена сообщениями"><code class="code" id="-o0hwx6_84">MessageChannel</code></span>, <span class="tooltip" id="-o0hwx6_83" title="Один из портов MessageChannel для передачи данных"><code class="code" id="-o0hwx6_85">MessagePort</code></span> &mdash; двунаправленные порты.</p></li><li class="list__item" id="-o0hwx6_72"><p><span class="tooltip" id="-o0hwx6_86" title="Список объектов (обычно ArrayBuffer), передаваемых без копирования"><code class="code" id="-o0hwx6_88">transferList</code></span> &mdash; список &laquo;передаваемых&raquo; объектов (например, <span class="tooltip" id="-o0hwx6_87" title="Низкоуровневый буфер бинарных данных фиксированной длины"><code class="code" id="-o0hwx6_89">ArrayBuffer</code></span>).</p></li><li class="list__item" id="-o0hwx6_73"><p><span class="tooltip" id="-o0hwx6_90" title="Буфер памяти, совместно используемый несколькими потоками"><code class="code" id="-o0hwx6_92">SharedArrayBuffer</code></span> и <span class="tooltip" id="-o0hwx6_91" title="Набор атомарных операций синхронизации для TypedArray"><code class="code" id="-o0hwx6_93">Atomics</code></span> &mdash; разделяемая память и атомарные операции.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="-o0hwx6_66"><p id="-o0hwx6_94">Передача сообщений использует <span class="tooltip" id="-o0hwx6_95" title="Алгоритм копирования сложных структур данных между потоками/воркерами"><code class="code" id="-o0hwx6_97">Structured Clone</code></span>: большинство структур копируются прозрачно; <span class="tooltip" id="-o0hwx6_96" title="Класс объектов, чьё «владение» можно передать другому контексту"><code class="code" id="-o0hwx6_98">Transferable</code></span> объекты можно передавать без копии, передавая &laquo;владение&raquo;.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_7" data-toc="-o0hwx6_7">Пример 1: простой воркер (два файла)</h2><p id="-o0hwx6_99">Рассчитаем тяжёлую функцию в отдельном потоке.</p><div class="code-block" data-lang="javascript">
            // main.js
        const { Worker, isMainThread } = require(&quot;node:worker_threads&quot;);

        if (isMainThread) {
            const worker = new Worker(__filename, {workerData: {n: 45}});
            worker.once(&quot;message&quot;, (result) =&gt; {
                console.log(&quot;fib:&quot;, result); // fib: 1134903170
            });
            worker.once(&quot;error&quot;, (e) =&gt; console.error(&quot;error:&quot;, e)); // error: ...
            worker.once(&quot;exit&quot;, (code) =&gt; console.log(&quot;exit:&quot;, code)); // exit: 0
        } else {
            const {parentPort, workerData} = require(&quot;node:worker_threads&quot;);

            function fib(n) {
                return n &lt; 2 ? n : fib(n - 1) + fib(n - 2);
            }

            const result = fib(workerData.n);
            parentPort.postMessage(result);
        }</div><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_101"><p id="-o0hwx6_102">Рекурсивный <code class="code" id="-o0hwx6_103">fib</code> &mdash; демонстрационная &laquo;печка&raquo;, он неэффективен. В реальности используйте алгоритмы с линейной сложностью или memoization.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_8" data-toc="-o0hwx6_8">Пример 2: воркер как отдельный модуль (многофайловый)</h2><p id="-o0hwx6_104">Так чаще организуют код в реальных проектах.</p><div class="code-block" data-lang="javascript">// main.js const { Worker } = require(&quot;node:worker_threads&quot;); const path = require(&quot;node:path&quot;);

        function runTask(payload) {
            return new Promise((resolve, reject) =&gt; {
                const worker = new Worker(path.join(__dirname, &quot;worker.js&quot;), {workerData: payload});
                worker.once(&quot;message&quot;, resolve);
                worker.once(&quot;error&quot;, reject);
                worker.once(&quot;exit&quot;, (code) =&gt; {
                    if (code !== 0) reject(new Error(&quot;exit &quot; + code));
                });
            });
        }

        (async () =&gt; {
            const res = await runTask({op: &quot;sum&quot;, items: [1, 2, 3]});
            console.log(&quot;sum:&quot;, res); // sum: 6
        })();</div><div class="code-block" data-lang="javascript">// worker.js
        const {workerData, parentPort} = require(&quot;node:worker_threads&quot;);

        function compute(data) {
            if (data.op === &quot;sum&quot;) return data.items.reduce((a, b) =&gt; a + b, 0);
            return null;
        }

        parentPort.postMessage(compute(workerData));</div><aside class="prompt" data-type="tip" data-title="" id="-o0hwx6_107"><p id="-o0hwx6_108">Отдельный файл повышает повторное использование и облегчает бандлинг/тестирование.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_9" data-toc="-o0hwx6_9">Пример 3: простой пул воркеров (переиспользование потоков)</h2><p id="-o0hwx6_109">Создаём фиксированное число воркеров и очередь задач.</p><div class="code-block" data-lang="javascript">
        // pool.js
        const { Worker } = require(&quot;node:worker_threads&quot;);
        const path = require(&quot;node:path&quot;);

        class WorkerPool {
            constructor(size = Math.max(1, require(&quot;node:os&quot;).cpus().length - 1)) {
                this.size = size;
                this.free = [];
                this.busy = new Set();
                this.queue = [];
                for (let i = 0; i &lt; size; i++) this.free.push(this._create());
            }

            _create() {
                const w = new Worker(path.join(__dirname, &quot;worker.js&quot;));
                w.on(&quot;message&quot;, (msg) =&gt; {
                    w.currentResolve &amp;&amp; w.currentResolve(msg);
                    w.currentResolve = w.currentReject = null;
                    this._release(w);
                });
                w.on(&quot;error&quot;, (err) =&gt; {
                    w.currentReject &amp;&amp; w.currentReject(err);
                    this.busy.delete(w);
                    // Создаём новый на замену
                    const nw = this._create();
                    this.free.push(nw);
                    this._drain();
                });
                w.on(&quot;exit&quot;, (code) =&gt; {
                    this.busy.delete(w);
                    if (code !== 0) {
                        const nw = this._create();
                        this.free.push(nw);
                    }
                    this._drain();
                });
                return w;
            }

            exec(payload) {
                return new Promise((resolve, reject) =&gt; {
                    this.queue.push({payload, resolve, reject});
                    this._drain();
                });
            }

            _drain() {
                while (this.free.length &gt; 0 &amp;&amp; this.queue.length &gt; 0) {
                    const w = this.free.pop();
                    const job = this.queue.shift();
                    this.busy.add(w);
                    w.currentResolve = job.resolve;
                    w.currentReject = job.reject;
                    w.postMessage(job.payload);
                }
            }

            _release(w) {
                this.busy.delete(w);
                this.free.push(w);
                this._drain();
            }

            async destroy() {
                const all = [...this.free, ...this.busy];
                await Promise.all(all.map((w) =&gt; w.terminate()));
                this.free = [];
                this.busy.clear();
            }
        }

        module.exports = {WorkerPool};</div><div class="code-block" data-lang="javascript">// worker.js
        const {parentPort} = require(&quot;node:worker_threads&quot;);

        parentPort.on(&quot;message&quot;, (task) =&gt; {
            let result = null;
            if (task.type === &quot;mul&quot;) result = task.a * task.b;
            if (task.type === &quot;sleep&quot;) {
                const end = Date.now() + task.ms;
                while (Date.now() &lt; end) {
                }
                result = task.ms;
            }
            parentPort.postMessage({id: task.id, result});
        });</div><div class="code-block" data-lang="javascript">// main.js
        const {WorkerPool} = require(&quot;./pool&quot;);

        (async () =&gt; {
            const pool = new WorkerPool(4);
            const jobs = [];
            for (let i = 0; i &lt; 8; i++) jobs.push(pool.exec({type: &quot;mul&quot;, a: i, b: i + 1, id: i}));
            const res = await Promise.all(jobs);
            console.log(res.length); // 8
            await pool.destroy();
        })();
        </div><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_113"><p id="-o0hwx6_114">&laquo;Залипание&raquo; в <code class="code" id="-o0hwx6_115">while</code> выше &mdash; намеренная CPU-нагрузка. Никогда не делайте так в главном потоке.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_10" data-toc="-o0hwx6_10">Передача данных: Structured Clone, Transferable, SharedArrayBuffer</h2><section class="chapter"><h3 id="-o0hwx6_116" data-toc="-o0hwx6_116">Копирование и передача владения</h3><p id="-o0hwx6_118">По умолчанию объекты копируются по <span class="tooltip" id="-o0hwx6_121" title="Алгоритм копирования сложных структур данных между потоками/воркерами">Structured Clone</span>. Для больших бинарных данных выгоднее передавать &laquo;владение&raquo; <span class="tooltip" id="-o0hwx6_122" title="Низкоуровневый буфер бинарных данных фиксированной длины"><code class="code" id="-o0hwx6_124">ArrayBuffer</code></span> через <span class="tooltip" id="-o0hwx6_123" title="Список объектов (обычно ArrayBuffer), передаваемых без копирования"><code class="code" id="-o0hwx6_125">transferList</code></span>.</p><div class="code-block" data-lang="javascript">
            // transfer.js
            const { Worker, isMainThread, parentPort } = require(&quot;node:worker_threads&quot;);

            if (isMainThread) {
                const worker = new Worker(__filename);
                const buf = new ArrayBuffer(1024 * 1024);
                const u8 = new Uint8Array(buf);
                u8[0] = 7;
                worker.postMessage({buf}, [buf]);
                worker.once(&quot;message&quot;, (m) =&gt; console.log(m)); // { first: 7 }
            } else {
                parentPort.once(&quot;message&quot;, ({buf}) =&gt; {
                    const view = new Uint8Array(buf);
                    parentPort.postMessage({first: view[0]});
                });
            }</div><aside class="prompt" data-type="note" data-title="" id="-o0hwx6_120"><p id="-o0hwx6_126">После передачи в <span class="tooltip" id="-o0hwx6_127" title="Список объектов (обычно ArrayBuffer), передаваемых без копирования">transferList</span> исходный буфер у отправителя становится &laquo;detached&raquo; (использование приводит к ошибкам).</p></aside></section><section class="chapter"><h3 id="-o0hwx6_117" data-toc="-o0hwx6_117">Разделяемая память и Atomics</h3><p id="-o0hwx6_128"><span class="tooltip" id="-o0hwx6_131" title="Буфер памяти, совместно используемый несколькими потоками"><code class="code" id="-o0hwx6_133">SharedArrayBuffer</code></span> позволяет разделять память между потоками, а <span class="tooltip" id="-o0hwx6_132" title="Набор атомарных операций синхронизации для TypedArray"><code class="code" id="-o0hwx6_134">Atomics</code></span> &mdash; синхронизировать доступ.</p><div class="code-block" data-lang="javascript">// shared.js
            const {Worker, isMainThread, parentPort, workerData} = require(&quot;node:worker_threads&quot;);

            if (isMainThread) {
                const sab = new SharedArrayBuffer(4);
                const view = new Int32Array(sab);
                const w = new Worker(__filename, {workerData: sab});
                Atomics.store(view, 0, 0);
                setTimeout(() =&gt; {
                    Atomics.store(view, 0, 42);
                    Atomics.notify(view, 0, 1);
                }, 100);
                w.once(&quot;message&quot;, (v) =&gt; console.log(v)); // 42
            } else {
                const view = new Int32Array(workerData);
                Atomics.wait(view, 0, 0);
                parentPort.postMessage(Atomics.load(view, 0));
            }</div><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_130"><p id="-o0hwx6_135">Злоупотребление <span class="tooltip" id="-o0hwx6_136" title="Буфер памяти, совместно используемый несколькими потоками">SAB</span> усложняет код и повышает риск гонок. Используйте только для действительно &laquo;горячих&raquo; путей.</p></aside></section></section><section class="chapter"><h2 id="-o0hwx6_11" data-toc="-o0hwx6_11">Двусторонние каналы: MessageChannel/MessagePort</h2><p id="-o0hwx6_137"><span class="tooltip" id="-o0hwx6_140" title="Пара связанных двунаправленных портов для обмена сообщениями"><code class="code" id="-o0hwx6_141">MessageChannel</code></span> создаёт пару портов. Их можно передать воркеру и использовать как выделенную шину.</p><div class="code-block" data-lang="javascript">
        // channel.js
        const { Worker, MessageChannel, isMainThread, parentPort } = require(&quot;node:worker_threads&quot;);

        if (isMainThread) {
            const worker = new Worker(__filename, {workerData: null});
            const {port1, port2} = new MessageChannel();
            worker.postMessage({port: port2}, [port2]);
            port1.on(&quot;message&quot;, (m) =&gt; console.log(&quot;got:&quot;, m)); // got: pong
            port1.postMessage(&quot;ping&quot;);
        } else {
            parentPort.once(&quot;message&quot;, ({port}) =&gt; {
                port.on(&quot;message&quot;, (m) =&gt; port.postMessage(m === &quot;ping&quot; ? &quot;pong&quot; : m));
            });
        }</div><aside class="prompt" data-type="tip" data-title="" id="-o0hwx6_139"><p id="-o0hwx6_142">Порты удобны для multiplexing и для передачи в &laquo;пул&raquo;, когда воркер обслуживает несколько клиентов.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_12" data-toc="-o0hwx6_12">Отмена задач и таймауты</h2><p id="-o0hwx6_143">Прямой &laquo;убийства&raquo; функции нет &mdash; есть <code class="code" id="-o0hwx6_146">worker.terminate()</code>, которое завершит поток целиком. Для «мягкой» отмены пошлите сигнал и регулярно проверяйте его в воркере.</p><div class="code-block" data-lang="javascript">
            // cancel.js
            const {Worker, isMainThread, parentPort} = require(&quot;node:worker_threads&quot;);

            if (isMainThread) {
                const w = new Worker(__filename);
                const timer = setTimeout(() =&gt; w.postMessage({type: &quot;cancel&quot;}), 50);
                w.once(&quot;message&quot;, (m) =&gt; console.log(m)); // { status: &quot;canceled&quot; }
                w.postMessage({type: &quot;start&quot;});
            } else {
                let canceled = false;
                parentPort.on(&quot;message&quot;, (m) =&gt; {
                    if (m.type === &quot;cancel&quot;) canceled = true;
                    if (m.type === &quot;start&quot;) {
                        let s = 0;
                        for (let i = 0; i &lt; 1e9; i++) {
                            s += i;
                            if (canceled) break;
                        }
                        parentPort.postMessage({status: canceled ? &quot;canceled&quot; : &quot;done&quot;});
                    }
                });
            }</div><aside class="prompt" data-type="note" data-title="" id="-o0hwx6_145"><p id="-o0hwx6_147">Для унификации протокола используйте собственные коды сообщений: <code class="code" id="-o0hwx6_148">{type: &quot;start&quot;|&quot;cancel&quot;|&quot;status&quot;}</code>.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_13" data-toc="-o0hwx6_13">ESM, TypeScript и бандлинг</h2><ul class="list _bullet" id="-o0hwx6_149"><li class="list__item" id="-o0hwx6_151"><p><span id="-o0hwx6_153"><b>ESM</b></span>: <code class="code" id="-o0hwx6_154">new Worker(new URL(&quot;worker.mjs&quot;, import.meta.url), { type: &quot;module&quot; })</code>.</p></li><li class="list__item" id="-o0hwx6_152"><p><span id="-o0hwx6_155"><b>Бандлеры</b></span>: убедитесь, что воркер лежит как отдельный asset; относительные пути из <code class="code" id="-o0hwx6_156">__filename</code>/<code class="code" id="-o0hwx6_157">import.meta.url</code> надёжнее &laquo;магических&raquo; строк.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_150"><p id="-o0hwx6_158">Пути до воркера часто &laquo;ломаются&raquo; при упаковке. Всегда тестируйте финальный артефакт (Docker/CI) с реальными путями.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_14" data-toc="-o0hwx6_14">Ошибки, выход, утечки</h2><ul class="list _bullet" id="-o0hwx6_159"><li class="list__item" id="-o0hwx6_161"><p><code class="code" id="-o0hwx6_165">worker.on(&quot;error&quot;)</code> &mdash; перехватывайте исключения.</p></li><li class="list__item" id="-o0hwx6_162"><p><code class="code" id="-o0hwx6_166">worker.on(&quot;exit&quot;)</code> &mdash; код выхода ≠ 0 =— аварийное завершение.</p></li><li class="list__item" id="-o0hwx6_163"><p><code class="code" id="-o0hwx6_167">worker.terminate()</code> &mdash; &laquo;жёсткое&raquo; завершение (освободит ресурсы).</p></li><li class="list__item" id="-o0hwx6_164"><p><code class="code" id="-o0hwx6_168">resourceLimits</code> &mdash; ограничение heap/stack при создании воркера.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_160"><p id="-o0hwx6_169">Не забывайте отписываться от событий и очищать очереди в пуле, иначе можно &laquo;нарастить&raquo; ссылки и получить утечку памяти.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_15" data-toc="-o0hwx6_15">Производительность: измеряем и считаем</h2><p id="-o0hwx6_170">Замеряйте &laquo;до/после&raquo; и учитывайте расходы на сериализацию/копирование.</p><div class="code-block" data-lang="javascript">
        // perf.js
        const { Worker } = require(&quot;node:worker_threads&quot;);
        const { performance } = require(&quot;node:perf_hooks&quot;);
        const path = require(&quot;node:path&quot;);

        (async () =&gt; {
            const start = performance.now();
            const w = new Worker(path.join(__dirname, &quot;worker.js&quot;), {workerData: {n: 45}});
            const t = await new Promise((res, rej) =&gt; {
                w.once(&quot;message&quot;, res);
                w.once(&quot;error&quot;, rej);
            });
            const dt = performance.now() - start;
            console.log(Math.round(dt)); // 1234
        })();</div><aside class="prompt" data-type="note" data-title="" id="-o0hwx6_172"><p id="-o0hwx6_173">Большие структуры лучше передавать как <span class="tooltip" id="-o0hwx6_174" title="Класс объектов, чьё «владение» можно передать другому контексту">переносимые</span> буферы; мелкие данные &mdash; как обычные сообщения.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_16" data-toc="-o0hwx6_16">Расширенный многофайловый пример: обработка изображений в пуле</h2><p id="-o0hwx6_175">Схема: главный поток читает список задач, пул раздаёт их воркерам, воркеры считают и возвращают результат. Здесь имитируем CPU-нагрузку.</p><div class="code-block" data-lang="javascript">
        // pool.js
        const { Worker } = require(&quot;node:worker_threads&quot;);
        const path = require(&quot;node:path&quot;);
        const os = require(&quot;node:os&quot;);

        class Pool {
            constructor(file, size = Math.max(1, os.cpus().length - 1)) {
                this.file = file;
                this.size = size;
                this.queue = [];
                this.id = 0;
                this.workers = Array.from({length: size}, () =&gt; this._spawn());
            }

            _spawn() {
                const w = new Worker(this.file);
                w.idle = true;
                w.on(&quot;message&quot;, (msg) =&gt; {
                    w.current &amp;&amp; w.current.resolve(msg);
                    w.current = null;
                    w.idle = true;
                    this._schedule();
                });
                w.on(&quot;error&quot;, (e) =&gt; {
                    w.current &amp;&amp; w.current.reject(e);
                    Object.assign(w, this._spawn()); // замена
                });
                return w;
            }

            exec(payload, transfer = []) {
                return new Promise((resolve, reject) =&gt; {
                    this.queue.push({payload, resolve, reject, transfer});
                    this._schedule();
                });
            }

            _schedule() {
                const w = this.workers.find(x =&gt; x.idle);
                if (!w) return;
                const job = this.queue.shift();
                if (!job) return;
                w.idle = false;
                w.current = job;
                w.postMessage(job.payload, job.transfer);
            }

            async destroy() {
                await Promise.all(this.workers.map((w) =&gt; w.terminate()));
            }
        }

        module.exports = {Pool};
        </div><div class="code-block" data-lang="javascript">
        // img.worker.js
        const {parentPort} = require(&quot;node:worker_threads&quot;);

        parentPort.on(&quot;message&quot;, ({buf, factor}) =&gt; {
            const view = new Uint8Array(buf);
            let sum = 0;
            for (let i = 0; i &lt; view.length; i++) sum += (view[i] * factor) | 0;
            parentPort.postMessage({sum});
        });
        </div><div class="code-block" data-lang="javascript">
        // main.js
        const {Pool} = require(&quot;./pool&quot;);
        const path = require(&quot;node:path&quot;);

        (async () =&gt; {
            const pool = new Pool(path.join(__dirname, &quot;img.worker.js&quot;), 4);
            const buf = new ArrayBuffer(1024 * 1024);
            const u8 = new Uint8Array(buf);
            for (let i = 0; i &lt; u8.length; i++) u8[i] = i &amp; 255;
            const res = await pool.exec({buf, factor: 3}, [buf]);
            console.log(res.sum &gt; 0); // true
            await pool.destroy();
        })();</div><aside class="prompt" data-type="tip" data-title="" id="-o0hwx6_179"><p id="-o0hwx6_180">Обратите внимание на <span class="tooltip" id="-o0hwx6_181" title="Список объектов (обычно ArrayBuffer), передаваемых без копирования">transferList</span> при вызове <code class="code" id="-o0hwx6_182">pool.exec</code> &mdash; мы передаём большой буфер без копирования.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_17" data-toc="-o0hwx6_17">Чеклист лучших практик</h2><ul class="list _bullet" id="-o0hwx6_183"><li class="list__item" id="-o0hwx6_184"><p>Оценивайте тип задачи: <span id="-o0hwx6_191"><b>CPU-bound &rarr; воркеры</b></span>, <span id="-o0hwx6_192"><b>I/O-bound &rarr; обычный асинхронный код</b></span>.</p></li><li class="list__item" id="-o0hwx6_185"><p>Используйте <span class="tooltip" id="-o0hwx6_193" title="Набор заранее созданных потоков для выполнения задач без накладных расходов на создание">пул</span>, а не бесконечное создание новых воркеров.</p></li><li class="list__item" id="-o0hwx6_186"><p>Определите протокол сообщений (типы, версии, поля ошибок).</p></li><li class="list__item" id="-o0hwx6_187"><p>Минимизируйте копирование: передавайте буферы через <span class="tooltip" id="-o0hwx6_194" title="Список объектов (обычно ArrayBuffer), передаваемых без копирования">transferList</span>.</p></li><li class="list__item" id="-o0hwx6_188"><p>Ограничивайте ресурсы <code class="code" id="-o0hwx6_195">resourceLimits</code> для &laquo;жадных&raquo; задач.</p></li><li class="list__item" id="-o0hwx6_189"><p>Логируйте <code class="code" id="-o0hwx6_196">error</code>, отслеживайте <code class="code" id="-o0hwx6_197">exit</code>, пишите метрики времени и очередей.</p></li><li class="list__item" id="-o0hwx6_190"><p>Тестируйте пути к воркеру в собранном окружении (Docker/CI).</p></li></ul></section><section class="chapter"><h2 id="-o0hwx6_18" data-toc="-o0hwx6_18">Типичные ошибки и подводные камни</h2><ul class="list _bullet" id="-o0hwx6_198"><li class="list__item" id="-o0hwx6_200"><p><span id="-o0hwx6_205"><b>Блокировка Event Loop</b></span>: запуск тяжёлого JS в главном потоке тормозит всё приложение.</p></li><li class="list__item" id="-o0hwx6_201"><p><span id="-o0hwx6_206"><b>Чрезмерная сериализация</b></span>: частые большие сообщения без <span class="tooltip" id="-o0hwx6_207" title="Класс объектов, чьё «владение» можно передать другому контексту">transfer</span> &mdash; потеря времени.</p></li><li class="list__item" id="-o0hwx6_202"><p><span id="-o0hwx6_208"><b>Ломаются пути</b></span>: относительные пути до воркера после бандлинга/обфускации.</p></li><li class="list__item" id="-o0hwx6_203"><p><span id="-o0hwx6_209"><b>Отсутствие стратегии отмены</b></span>: &laquo;вечные&raquo; воркеры без <code class="code" id="-o0hwx6_210">terminate()</code> и протокола <code class="code" id="-o0hwx6_211">cancel</code>.</p></li><li class="list__item" id="-o0hwx6_204"><p><span id="-o0hwx6_212"><b>Утечки</b></span>: забытые слушатели и ссылки в пуле.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-o0hwx6_199"><p id="-o0hwx6_213">Не запускайте недоверенный код в воркере &laquo;как есть&raquo;: поток разделяет права процесса. Для жёсткой изоляции &mdash; отдельный процесс/контейнер.</p></aside></section><section class="chapter"><h2 id="-o0hwx6_19" data-toc="-o0hwx6_19">Сравнение: worker_threads vs child_process vs cluster</h2><ul class="list _bullet" id="-o0hwx6_214"><li class="list__item" id="-o0hwx6_216"><p><span class="tooltip" id="-o0hwx6_219" title="Модуль Node.js для работы с потоками JavaScript"><code class="code" id="-o0hwx6_220">worker_threads</code></span>: общая память процесса, низкие накладные расходы, быстрые сообщения, слабая изоляция.</p></li><li class="list__item" id="-o0hwx6_217"><p><span class="tooltip" id="-o0hwx6_221" title="Модуль Node.js для запуска процессов-потомков"><code class="code" id="-o0hwx6_222">child_process</code></span>: сильная изоляция, IPC медленнее, больше памяти.</p></li><li class="list__item" id="-o0hwx6_218"><p><span class="tooltip" id="-o0hwx6_223" title="Модуль Node.js для форка нескольких процессов, разделяющих один порт"><code class="code" id="-o0hwx6_224">cluster</code></span>: масштабирование входящих соединений по ядрам, каждый &laquo;воркер&raquo; &mdash; это процесс.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="-o0hwx6_215"><p id="-o0hwx6_225">Если вам нужна и многопоточность, и масштабирование по ядрам &mdash; комбинируйте: несколько процессов, внутри каждого &mdash; пул <span class="tooltip" id="-o0hwx6_226" title="Поток исполнения JavaScript с собственным Event Loop и изолятом V8">воркеров</span>.</p></aside></section><div class="last-modified">24 сентября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="async.html" class="navigation-links__prev">Асинхронность и неблокирующие вызовы. Промисы</a><a href="typescript.html" class="navigation-links__next">TypeScript</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>