<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:35.0467201"><title>Альтернативные протоколы | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"-ezzax_2","level":0,"title":"Зачем нужны альтернативные протоколы","anchor":"#-ezzax_2"},{"id":"-ezzax_3","level":0,"title":"WebSocket (WS)","anchor":"#-ezzax_3"},{"id":"-ezzax_4","level":0,"title":"Polling (опрос)","anchor":"#-ezzax_4"},{"id":"-ezzax_5","level":0,"title":"RPC-системы: общий взгляд","anchor":"#-ezzax_5"},{"id":"-ezzax_6","level":0,"title":"JSON-RPC","anchor":"#-ezzax_6"},{"id":"-ezzax_7","level":0,"title":"gRPC","anchor":"#-ezzax_7"},{"id":"-ezzax_8","level":0,"title":"GraphQL","anchor":"#-ezzax_8"},{"id":"-ezzax_9","level":0,"title":"WebRTC (p2p)","anchor":"#-ezzax_9"},{"id":"-ezzax_10","level":0,"title":"Сравнение и выбор протокола","anchor":"#-ezzax_10"},{"id":"-ezzax_11","level":0,"title":"Практические рекомендации","anchor":"#-ezzax_11"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Альтернативные протоколы | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/altprotocols.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Альтернативные протоколы | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/altprotocols.html#webpage",
    "url": "writerside-documentation//1.0.0/altprotocols.html",
    "name": "Альтернативные протоколы | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="AltProtocols" data-main-title="Альтернативные протоколы" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_Backend.topic|Backend"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="AltProtocols" id="AltProtocols.topic">Альтернативные протоколы</h1><section class="chapter"><h2 id="-ezzax_2" data-toc="-ezzax_2">Зачем нужны альтернативные протоколы</h2><p id="-ezzax_12">Классический HTTP/1.1 request-response отлично подходит для простых синхронных операций: клиент сделал запрос &mdash; сервер вернул ответ. Но в реальных системах все чаще требуются двунаправленные каналы, потоковая доставка данных, строгие контракты, эффективная бинарная сериализация и прямые соединения между клиентами. Здесь в игру вступают <span class="tooltip" id="-ezzax_15" title="Сетевые протокольные подходы помимо классического HTTP request-response: WS, RPC, GraphQL, WebRTC">альтернативные протоколы</span>: <span class="tooltip" id="-ezzax_16" title="Постоянное двунаправленное соединение поверх HTTP upgrade для обмена сообщениями клиент↔сервер">WebSocket</span>, семейство <span class="tooltip" id="-ezzax_17" title="Модель удаленного вызова процедур с передачей аргументов и получением результата или потоков">RPC</span> (включая <span class="tooltip" id="-ezzax_18" title="Легкий текстовый RPC-протокол на JSON (версии 2.0), работает поверх разных транспортов">JSON-RPC</span> и <span class="tooltip" id="-ezzax_19" title="Высокопроизводительный RPC-фреймворк поверх HTTP/2 с бинарной сериализацией Protocol Buffers">gRPC</span>), <span class="tooltip" id="-ezzax_20" title="Язык запросов и схема типов для гибкого выбора данных клиентом (query/mutation/subscription)">GraphQL</span> и <span class="tooltip" id="-ezzax_21" title="Стек p2p-связи для аудио/видео/данных между клиентами с шифрованием и низкой задержкой">WebRTC</span>. Каждый решает свою подзадачу: realtime, строгий контракт, оптимизация трафика, p2p и мультимедийные стримы.</p><ul class="list _bullet" id="-ezzax_13"><li class="list__item" id="-ezzax_22"><p><span id="-ezzax_26"><b>Двунаправленность и события:</b></span> push-уведомления, чаты, биржевые котировки, телеметрия.</p></li><li class="list__item" id="-ezzax_23"><p><span id="-ezzax_27"><b>Строгие контракты и схемы:</b></span> описание типов и автоматическая генерация кода.</p></li><li class="list__item" id="-ezzax_24"><p><span id="-ezzax_28"><b>Производительность:</b></span> бинарные форматы (<span class="tooltip" id="-ezzax_29" title="IDL и бинарный формат сериализации от Google; компактный, быстрый, эволюционируемый">Protocol Buffers</span>) и потоковые RPC сокращают задержки и трафик.</p></li><li class="list__item" id="-ezzax_25"><p><span id="-ezzax_30"><b>P2P и мультимедиа:</b></span> прямые соединения для видео/аудио/данных без центрального проксирования.</p></li></ul><aside class="prompt" data-type="warning" data-title="" id="-ezzax_14"><p>Ошибка выбора протокола &laquo;на слух&raquo;. Без анализа домена легко выбрать модный, но неподходящий инструмент. Сначала формализуйте требования: типы трафика (события, запрос-ответ, потоки), SLIs (latency, throughput), ограничения сети и безопасности.</p></aside></section><section class="chapter"><h2 id="-ezzax_3" data-toc="-ezzax_3">WebSocket (WS)</h2><p id="-ezzax_31"><span class="tooltip" id="-ezzax_37" title="Постоянное двунаправленное соединение поверх HTTP upgrade для обмена сообщениями клиент↔сервер">WebSocket</span> &mdash; это постоянное TCP-соединение между клиентом и сервером поверх HTTP/1.1 upgrade или HTTP/2 (H2 WebSocket), позволяющее обеим сторонам отправлять сообщения в любой момент времени. Хорошо подходит для realtime UI (чаты, игры, панели мониторинга) и широковещательных событий.</p><aside class="prompt" data-type="note" data-title="" id="-ezzax_32"><p>WS решает задачу серверного push без долгого опроса. Он особенно полезен там, где количество событий велико, а задержка критична.</p></aside><section class="chapter"><h3 id="-ezzax_33" data-toc="-ezzax_33">Как выглядит рукопожатие (handshake)</h3><div class="code-block" data-lang="http">
GET /realtime HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Version: 13
Origin: https://app.example.com
            </div><div class="code-block" data-lang="http">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
            </div></section><section class="chapter"><h3 id="-ezzax_34" data-toc="-ezzax_34">Пример текстового сообщения по WS</h3><div class="code-block" data-lang="json">
                {
                    &quot;type&quot;: &quot;price_update&quot;,
                    &quot;symbol&quot;: &quot;AAPL&quot;,
                    &quot;price&quot;: 232.15,
                    &quot;ts&quot;: 1727606400000
                } </div></section><aside class="prompt" data-type="tip" data-title="" id="-ezzax_35"><p>Используйте компрессию сообщений (permessage-deflate) осторожно: это экономит трафик, но увеличивает нагрузку на CPU.</p></aside><aside class="prompt" data-type="warning" data-title="" id="-ezzax_36"><p>Безопасность: защищайте соединение WSS и проверяйте токен аутентификации при установке и периодически (re-auth), иначе возможен угон сессии. Учитывайте, что CORS не применяется к WS так же, как к HTTP &mdash; нужен собственный контроль origin/токена.</p></aside></section><section class="chapter"><h2 id="-ezzax_4" data-toc="-ezzax_4">Polling (опрос)</h2><p id="-ezzax_41">Polling &mdash; это периодический опрос сервера по протоколу <span class="tooltip" id="-ezzax_48" title="Протокол передачи гипертекста для общения клиента и сервера">HTTP</span> с целью узнать, появились ли новые данные или события. Клиент по таймеру отправляет запрос, сервер отвечает текущим состоянием. Такой подход прост и работает &laquo;везде&raquo;, но может быть неэффективным при высокой частоте запросов или редких обновлениях.</p><section class="chapter"><h3 id="-ezzax_42" data-toc="-ezzax_42">Короткий (регулярный) polling</h3><p id="-ezzax_49">Клиент с фиксированным интервалом (например, каждые 5&ndash;10 секунд) отправляет одинаковый запрос. Подходит для медленно меняющихся данных или в условиях, когда нельзя держать постоянное соединение.</p><div class="code-block" data-lang="http">
GET /api/notifications?limit=20 HTTP/1.1
Host: example.com
Accept: application/json
            </div><div class="code-block" data-lang="json">
                {
                    &quot;items&quot;: [
                        {
                            &quot;id&quot;: &quot;n-1201&quot;,
                            &quot;type&quot;: &quot;message&quot;,
                            &quot;ts&quot;: 1727606400000
                        }
                    ],
                    &quot;hasMore&quot;: false
                } </div><aside class="prompt" data-type="note" data-title="" id="-ezzax_52"><p>Увеличивайте интервал опроса, если изменений нет (backoff), и уменьшайте при появлении активности &mdash; это снижает нагрузку и трафик.</p></aside></section><section class="chapter"><h3 id="-ezzax_43" data-toc="-ezzax_43">Длинный polling (long polling)</h3><p id="-ezzax_53">Клиент отправляет запрос и держит соединение открытым, пока сервер не пошлет ответ (или не истечет таймаут). Если изменений нет, сервер отвечает ближе к таймауту, после чего клиент немедленно повторяет запрос. Таким образом достигается почти &laquo;реалтайм&raquo; без постоянного двунаправленного канала.</p><div class="code-block" data-lang="http">
                GET /api/events/stream?cursor=eyJvZmZzZXQiOjEyMzR9 HTTP/1.1
                Host: example.com
                Accept: application/json
                Cache-Control: no-cache
            </div><div class="code-block" data-lang="json">
                {
                    &quot;events&quot;: [
                        {
                            &quot;type&quot;: &quot;price_update&quot;,
                            &quot;symbol&quot;: &quot;AAPL&quot;,
                            &quot;price&quot;: 232.15,
                            &quot;ts&quot;: 1727606401000
                        }
                    ],
                    &quot;nextCursor&quot;: &quot;eyJvZmZzZXQiOjEyMzV9&quot;
                } </div><aside class="prompt" data-type="tip" data-title="" id="-ezzax_56"><p>Держите серверный таймаут 25&ndash;55 секунд (в зависимости от инфраструктуры) и возвращайте пустой ответ по таймауту, чтобы клиент сразу переоткрыл запрос.</p></aside></section><section class="chapter"><h3 id="-ezzax_44" data-toc="-ezzax_44">Оптимизации и заголовки кэширования</h3><p id="-ezzax_57">Даже при polling можно резко сократить трафик с помощью условных запросов и кэша.</p><div class="code-block" data-lang="http">
                GET /api/feed HTTP/1.1
                Host: example.com
                Accept: application/json
                If-None-Match: &quot;feed-v3-9f1c&quot;
                If-Modified-Since: Tue, 30 Sep 2025 00:00:00 GMT
            </div><div class="code-block" data-lang="http">
                HTTP/1.1 304 Not Modified
        ETag: &quot;feed-v3-9f1c&quot;
        Cache-Control: no-cache
            </div><aside class="prompt" data-type="note" data-title="" id="-ezzax_60"><p>Используйте <span class="tooltip" id="-ezzax_61" title="Тег версии ресурса для условных запросов и кеширования">ETag</span> и Last-Modified : при отсутствии изменений сервер вернет 304, экономя трафик и CPU.</p></aside></section><section class="chapter"><h3 id="-ezzax_45" data-toc="-ezzax_45">Когда выбирать polling, а когда нет</h3><ul class="list _bullet" id="-ezzax_62"><li class="list__item" id="-ezzax_63"><p><span id="-ezzax_66"><b>Выберите polling</b></span>, если данные меняются редко, а инфраструктура не позволяет держать постоянные соединения (например, ограниченные прокси/балансировщики).</p></li><li class="list__item" id="-ezzax_64"><p><span id="-ezzax_67"><b>Рассмотрите long polling</b></span>, если нужен почти &laquo;реалтайм&raquo;, но WebSocket/HTTP/2 недоступны.</p></li><li class="list__item" id="-ezzax_65"><p><span id="-ezzax_68"><b>Предпочтительнее WS/SSE</b></span>, если требуется частая доставка событий с минимальной задержкой и двунаправленность (<span class="tooltip" id="-ezzax_69" title="Постоянное двунаправленное соединение поверх HTTP upgrade для обмена сообщениями клиент↔сервер">WS</span>) или односторонний поток сервер&rarr;клиент (SSE).</p></li></ul></section><aside class="prompt" data-type="warning" data-title="" id="-ezzax_46"><p>Нагрузочные риски: частый polling от тысяч клиентов создает &laquo;пилообразную&raquo; нагрузку (thundering herd), лишний трафик и расходы. Смягчайте экспоненциальным backoff, джиттером (рандомизация интервалов), условными запросами и ограничением частоты.</p></aside><aside class="prompt" data-type="tip" data-title="" id="-ezzax_47"><p>Стандартизируйте контракт: передавайте <code class="code" id="-ezzax_70">cursor</code>/<code class="code" id="-ezzax_71">since</code> для инкрементального чтения, TTL для кэша и четко документируйте серверные таймауты long polling.</p></aside></section><section class="chapter"><h2 id="-ezzax_5" data-toc="-ezzax_5">RPC-системы: общий взгляд</h2><p id="-ezzax_72"><span class="tooltip" id="-ezzax_75" title="Модель удаленного вызова процедур с передачей аргументов и получением результата или потоков">RPC</span> (Remote Procedure Call) моделирует удаленный вызов функции как локальный: клиент вызывает метод с аргументами, сервер возвращает результат (или поток результатов). Ключевые элементы: <span class="tooltip" id="-ezzax_76" title="Язык описания интерфейсов и типов (схем) для генерации кода клиентов и серверов">IDL</span>/ схема для описания типов, транспорт (HTTP/2, HTTP/3, TCP), и формат сериализации (JSON, Protobuf, Avro).</p><ul class="list _bullet" id="-ezzax_73"><li class="list__item" id="-ezzax_77"><p><span id="-ezzax_81"><b>Unary:</b></span> один запрос &mdash; один ответ.</p></li><li class="list__item" id="-ezzax_78"><p><span id="-ezzax_82"><b>Server streaming:</b></span> один запрос &mdash; поток ответов.</p></li><li class="list__item" id="-ezzax_79"><p><span id="-ezzax_83"><b>Client streaming:</b></span> поток запросов &mdash; один ответ.</p></li><li class="list__item" id="-ezzax_80"><p><span id="-ezzax_84"><b>Bidirectional streaming:</b></span> двунаправленный поток.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="-ezzax_74"><p>RPC удобен для сервис-сервис общения в микросервисах, где важны строгие контракты и эволюция API.</p></aside></section><section class="chapter"><h2 id="-ezzax_6" data-toc="-ezzax_6">JSON-RPC</h2><p id="-ezzax_85"><span class="tooltip" id="-ezzax_90" title="Легкий текстовый RPC-протокол на JSON (версии 2.0), работает поверх разных транспортов">JSON-RPC 2.0</span> &mdash; легкий текстовый RPC-протокол без строгой схемы типов: сообщения &mdash; это JSON-объекты с полями jsonrpc, method, params и id. Работает поверх HTTP(S), WS или другого транспорта.</p><section class="chapter"><h3 id="-ezzax_86" data-toc="-ezzax_86">Пример запрос-ответ</h3><div class="code-block" data-lang="json">
                {
                    &quot;jsonrpc&quot;: &quot;2.0&quot;,
                    &quot;method&quot;: &quot;subtract&quot;,
                    &quot;params&quot;: [
                        42,
                        23
                    ],
                    &quot;id&quot;: 1
                } </div><div class="code-block" data-lang="json">
                {
                    &quot;jsonrpc&quot;: &quot;2.0&quot;,
                    &quot;result&quot;: 19,
                    &quot;id&quot;: 1
                } </div></section><section class="chapter"><h3 id="-ezzax_87" data-toc="-ezzax_87">Пример ошибки</h3><div class="code-block" data-lang="json">
                {
                    &quot;jsonrpc&quot;: &quot;2.0&quot;,
                    &quot;error&quot;: {
                        &quot;code&quot;: -32601,
                        &quot;message&quot;: &quot;Method not found&quot;
                    },
                    &quot;id&quot;: 1
                } </div></section><section class="chapter"><h3 id="-ezzax_88" data-toc="-ezzax_88">Пакетные вызовы (batch)</h3><div class="code-block" data-lang="json">
                [
                    {
                        &quot;jsonrpc&quot;: &quot;2.0&quot;,
                        &quot;method&quot;: &quot;sum&quot;,
                        &quot;params&quot;: [
                            1,
                            2,
                            3
                        ],
                        &quot;id&quot;: 2
                    },
                    {
                        &quot;jsonrpc&quot;: &quot;2.0&quot;,
                        &quot;method&quot;: &quot;notify_hello&quot;,
                        &quot;params&quot;: [
                            7
                        ]
                    },
                    {
                        &quot;jsonrpc&quot;: &quot;2.0&quot;,
                        &quot;method&quot;: &quot;subtract&quot;,
                        &quot;params&quot;: [
                            42,
                            23
                        ],
                        &quot;id&quot;: 3
                    }
                ] </div></section><aside class="prompt" data-type="warning" data-title="" id="-ezzax_89"><p>Отсутствие строгой схемы усложняет эволюцию API: клиенты могут отправлять неожиданные типы. Добавляйте собственные схемы валидации (JSON Schema) и версионирование методов.</p></aside></section><section class="chapter"><h2 id="-ezzax_7" data-toc="-ezzax_7">gRPC</h2><p id="-ezzax_95"><span class="tooltip" id="-ezzax_99" title="Высокопроизводительный RPC-фреймворк поверх HTTP/2 с бинарной сериализацией Protocol Buffers">gRPC</span> &mdash; фреймворк RPC поверх HTTP/2 с бинарной сериализацией <span class="tooltip" id="-ezzax_100" title="IDL и бинарный формат сериализации от Google; компактный, быстрый, эволюционируемый">Protocol Buffers</span> (protobuf). Обеспечивает строгие контракты через .proto-файлы, генерацию клиент/сервер кода, 4 режима вызовов (unary/streams) и эффективную передачу данных.</p><section class="chapter"><h3 id="-ezzax_96" data-toc="-ezzax_96">Пример .proto контракта</h3><div class="code-block" data-lang="protobuf">
syntax = &quot;proto3&quot;;

package orders.v1;

// Сущность и DTO
message OrderRequest {
    string id = 1;
}

message Order {
    string id = 1;
    string status = 2;
}

// Сервис и методы
service OrderService {
    rpc GetOrder (OrderRequest) returns (Order);
    rpc StreamOrders (OrderRequest) returns (stream Order);
    rpc UploadChunks (stream Chunk) returns (UploadResult);
    rpc Chat (stream Message) returns (stream Message);
}

message Chunk { bytes data = 1; }
message UploadResult { string fileId = 1; }
message Message { string text = 1; int64 ts = 2; }
</div></section><aside class="prompt" data-type="note" data-title="" id="-ezzax_97"><p>HTTP/2 мультиплексирует несколько RPC по одному соединению, уменьшает накладные расходы заголовков и поддерживает потоки.</p></aside><aside class="prompt" data-type="warning" data-title="" id="-ezzax_98"><p>Совместимость схем: поля в protobuf нужно эволюционировать аккуратно &mdash; не переиспользуйте номера полей, удаленные поля помечайте reserved. Неправильная эволюция ломает межверсную совместимость клиентов.</p></aside></section><section class="chapter"><h2 id="-ezzax_8" data-toc="-ezzax_8">GraphQL</h2><p id="-ezzax_102"><span class="tooltip" id="-ezzax_107" title="Язык запросов и схема типов для гибкого выбора данных клиентом (query/mutation/subscription)">GraphQL</span> &mdash; язык запросов к API и схема типов. Клиент формирует точный запрос к графу данных (query) и получает ровно необходимые поля. Также поддерживаются mutation и subscription (обычно поверх WS).</p><section class="chapter"><h3 id="-ezzax_103" data-toc="-ezzax_103">Пример схемы (SDL)</h3><div class="code-block" data-lang="graphql"> type Order { id: ID! status: String! total: Float! items: [OrderItem!]! }

type OrderItem {
    sku: String!
    qty: Int!
    price: Float!
}

type Query {
    order(id: ID!): Order
    orders(limit: Int = 10): [Order!]!
}

type Mutation {
    updateOrderStatus(id: ID!, status: String!): Order!
}

type Subscription {
    orderUpdated(id: ID!): Order!
}
</div></section><section class="chapter"><h3 id="-ezzax_104" data-toc="-ezzax_104">Пример запроса и ответа</h3><div class="code-block" data-lang="graphql">
query GetOrder($id: ID!) {
    order(id: $id) {
        id
        status
        total
        items { sku qty }
    }
}
</div><div class="code-block" data-lang="json">
{
    &quot;data&quot;: {
        &quot;order&quot;: {
            &quot;id&quot;: &quot;o-1001&quot;,
            &quot;status&quot;: &quot;SHIPPED&quot;,
            &quot;total&quot;: 149.90,
            &quot;items&quot;: [
                {
                    &quot;sku&quot;: &quot;A-1&quot;,
                    &quot;qty&quot;: 2
                }
            ]
        }
    }
}
</div></section><aside class="prompt" data-type="warning" data-title="" id="-ezzax_105"><p>N+1 проблема: при наивной реализации резолверов сервер может ходить в БД по одному запросу на каждый объект. Используйте батчеры/дата-лоадеры и кэширование.</p></aside><aside class="prompt" data-type="note" data-title="" id="-ezzax_106"><p>Схема &mdash; контракт: документируйте директивы, nullable/required поля и версии. Стабильная схема снижает риск поломок на фронте.</p></aside></section><section class="chapter"><h2 id="-ezzax_9" data-toc="-ezzax_9">WebRTC (p2p)</h2><p id="-ezzax_111"><span class="tooltip" id="-ezzax_117" title="Стек p2p-связи для аудио/видео/данных между клиентами с шифрованием и низкой задержкой">WebRTC</span> &mdash; стек для установления peer-to-peer соединений между браузерами и нативными приложениями. Поддерживает передачу аудио/видео и данных (<span class="tooltip" id="-ezzax_118" title="Канал передачи произвольных двоичных/текстовых данных в WebRTC">DataChannel</span>) с минимальными задержками. Для сигналинга используется сторонний канал (обычно HTTP/WS), обмен <span class="tooltip" id="-ezzax_119" title="Session Description Protocol — формат описания параметров медиа-сеанса в WebRTC">SDP</span> и <span class="tooltip" id="-ezzax_120" title="Interactive Connectivity Establishment — алгоритм поиска p2p-пути с учетом NAT">ICE</span>-кандидатами; для обхода NAT &mdash; <span class="tooltip" id="-ezzax_121" title="Сервис определения публичного адреса/порта клиента за NAT">STUN</span>/<span class="tooltip" id="-ezzax_122" title="Ретранслятор трафика, когда p2p недоступно; повышает надежность ценой затрат">TURN</span>.</p><section class="chapter"><h3 id="-ezzax_112" data-toc="-ezzax_112">Фрагмент SDP offer</h3><div class="code-block" data-lang="none">
                v=0
                o=- 46117327 2 IN IP4 127.0.0.1
                s=-
                t=0 0
                a=group:BUNDLE 0 1
                m=audio 9 UDP/TLS/RTP/SAVPF 111
                a=rtpmap:111 opus/48000/2
                m=application 9 DTLS/SCTP 5000
                a=sctp-port:5000
            </div></section><section class="chapter"><h3 id="-ezzax_113" data-toc="-ezzax_113">ICE-кандидат (как обычно передают по сигналингу)</h3><div class="code-block" data-lang="json">
                {
                    &quot;candidate&quot;: &quot;candidate:1 1 UDP 2122260223 192.0.2.10 53405 typ host&quot;,
                    &quot;sdpMid&quot;: &quot;0&quot;,
                    &quot;sdpMLineIndex&quot;: 0
                } </div></section><section class="chapter"><h3 id="-ezzax_114" data-toc="-ezzax_114">Сообщение по DataChannel</h3><div class="code-block" data-lang="json">
                {
                    &quot;type&quot;: &quot;cursor&quot;,
                    &quot;x&quot;: 512,
                    &quot;y&quot;: 284,
                    &quot;ts&quot;: 1727606400123
                } </div></section><aside class="prompt" data-type="warning" data-title="" id="-ezzax_115"><p>TURN трафик: при неудачном p2p WebRTC пойдет через TURN-сервер &mdash; это нагрузка и стоимость. Планируйте емкость и бюджет, мониторьте долю relayed-сессий.</p></aside><aside class="prompt" data-type="note" data-title="" id="-ezzax_116"><p>Безопасность и приватность: шифрование в WebRTC обязательное (SRTP/DTLS). Хранить ключи пользователей на TURN нельзя &mdash; он только ретранслятор.</p></aside></section><section class="chapter"><h2 id="-ezzax_10" data-toc="-ezzax_10">Сравнение и выбор протокола</h2><ul class="list _bullet" id="-ezzax_126"><li class="list__item" id="-ezzax_128"><p><span id="-ezzax_133"><b>WS:</b></span> простой двунаправленный канал для событий и UI realtime. Нет жесткой схемы &mdash; добавьте свою валидацию.</p></li><li class="list__item" id="-ezzax_129"><p><span id="-ezzax_134"><b>JSON-RPC:</b></span> легкий RPC на JSON, быстро внедрить, но меньше строгости. Хорош для внутренних инструментов и прототипов.</p></li><li class="list__item" id="-ezzax_130"><p><span id="-ezzax_135"><b>gRPC:</b></span> строгие контракты, генерация кода, потоки, эффективность HTTP/2 + Protobuf. Идеален для сервис-сервис API.</p></li><li class="list__item" id="-ezzax_131"><p><span id="-ezzax_136"><b>GraphQL:</b></span> гибкий отбор данных клиентом, единая точка входа. Требует дисциплины (перфоманс, кеш, N+1).</p></li><li class="list__item" id="-ezzax_132"><p><span id="-ezzax_137"><b>WebRTC:</b></span> p2p мультимедиа/данные с минимальной задержкой. Нужен сигналинг, STUN/TURN и внимательная сетвая архитектура.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="-ezzax_127"><p>Опишите SLA/SLI до выбора: требования к latency (p50/p95), к потерям, к объему сообщений и направлению потоков. Это сократит риск неправильного выбора.</p></aside></section><section class="chapter"><h2 id="-ezzax_11" data-toc="-ezzax_11">Практические рекомендации</h2><ul class="list _bullet" id="-ezzax_138"><li class="list__item" id="-ezzax_139"><p>Для стриминга телеметрии/событий в UI начните с WS, добавьте схему сообщений (JSON Schema) и версионирование.</p></li><li class="list__item" id="-ezzax_140"><p>Для межсервисных контрактов и высокой нагрузки рассмотрите gRPC; для публичного API &mdash; REST/GraphQL гибрид.</p></li><li class="list__item" id="-ezzax_141"><p>Для видеосвязи и коллаборации &mdash; WebRTC с продуманной сигналинг-схемой и метриками доли прямых/relayed соединений.</p></li><li class="list__item" id="-ezzax_142"><p>Для быстрых внутренних интеграций подойдет JSON-RPC, но запланируйте миграцию к схематизированному API при росте.</p></li></ul></section><div class="last-modified">01 октября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="http.html" class="navigation-links__prev">HTTP</a><a href="auth.html" class="navigation-links__next">Авторизация и Аутентификация</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>