<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:35.0700633"><title>SQL | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"sql","level":0,"title":"Основные команды SQL","anchor":"#sql"},{"id":"tw29xn_6","level":0,"title":"Операции с данными","anchor":"#tw29xn_6"},{"id":"tw29xn_7","level":0,"title":"Транзакции и индексы","anchor":"#tw29xn_7"},{"id":"tw29xn_8","level":0,"title":"Практические примеры","anchor":"#tw29xn_8"},{"id":"tw29xn_9","level":0,"title":"Подзапросы и соединения","anchor":"#tw29xn_9"},{"id":"tw29xn_10","level":0,"title":"Агрегатные функции","anchor":"#tw29xn_10"},{"id":"tw29xn_11","level":0,"title":"Индексирование и оптимизация запросов","anchor":"#tw29xn_11"},{"id":"tw29xn_12","level":0,"title":"Безопасность и права доступа","anchor":"#tw29xn_12"},{"id":"tw29xn_13","level":0,"title":"Резервное копирование и восстановление","anchor":"#tw29xn_13"},{"id":"tw29xn_14","level":0,"title":"Триггеры и функции","anchor":"#tw29xn_14"},{"id":"tw29xn_15","level":0,"title":"Последовательности и идентификаторы","anchor":"#tw29xn_15"},{"id":"tw29xn_16","level":0,"title":"Вью и материализованные вью","anchor":"#tw29xn_16"},{"id":"common-table-expressions-cte","level":0,"title":"Common Table Expressions (CTE)","anchor":"#common-table-expressions-cte"},{"id":"tw29xn_18","level":0,"title":"Регулярные выражения","anchor":"#tw29xn_18"},{"id":"window-functions","level":0,"title":"Окна (Window Functions)","anchor":"#window-functions"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="SQL | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/sql.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="SQL | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/sql.html#webpage",
    "url": "writerside-documentation//1.0.0/sql.html",
    "name": "SQL | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="SQL" data-main-title="SQL" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_Data.topic|Хранение данных"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="SQL" id="SQL.md">SQL</h1><aside class="prompt" data-type="warning" data-title="" id="tw29xn_3"><p>Все запросы вы можете протестировать запустив базу в докере. Прекрасно подойдет пример из конца топика про Docker. </p><p id="tw29xn_20">Перейдите на <a href="http://localhost:8082/login?next=/" id="tw29xn_23" data-external="true" rel="noopener noreferrer" target="_blank">http://localhost:8082</a></p><p id="tw29xn_21">Авторизуйтесь с помощью <code class="code" id="tw29xn_24">admin@domain.com</code> и <code class="code" id="tw29xn_25">adminpassword</code></p><p id="tw29xn_22">К базе в PGAdmin внутри докера можно будет подключиться по следующим параметрам <code class="code" id="tw29xn_26">host: postgres</code> <code class="code" id="tw29xn_27">port: 5432</code> <code class="code" id="tw29xn_28">user: myuser</code> <code class="code" id="tw29xn_29">password: mypassword</code></p></aside><p id="tw29xn_4">Язык <span class="tooltip" id="tw29xn_30" title="Декларативный язык запросов к реляционным БД: описывает, какие данные нужны, а не как их получать">SQL</span> декларативный: вы описываете <span id="tw29xn_31"><b>какие</b></span> данные нужны, а не <span id="tw29xn_32"><b>как</b></span> их получить. Базовый набор команд одинаков в большинстве СУБД.</p><section class="chapter"><h2 id="sql" data-toc="sql">Основные команды SQL</h2><p id="tw29xn_33">Команда <span class="tooltip" id="tw29xn_46" title="Оператор выборки данных из одной или нескольких таблиц">SELECT</span> выбирает столбцы из таблицы. Минимальная форма: указать столбцы и источник данных.</p><div class="code-block" data-lang="sql">
SELECT column1, column2
FROM tablename;
</div><p id="tw29xn_35"><span class="tooltip" id="tw29xn_47" title="Оператор добавления новых строк в таблицу">INSERT</span> добавляет новые записи. Порядок значений должен соответствовать перечисленным столбцам.</p><div class="code-block" data-lang="sql">
INSERT INTO tablename (column1, column2) 
VALUES ('value1', 'value2');
</div><p id="tw29xn_37"><span class="tooltip" id="tw29xn_48" title="Оператор изменения существующих строк таблицы">UPDATE</span> изменяет существующие данные. Ограничивайте изменяемые строки условием <span class="tooltip" id="tw29xn_49" title="Условие фильтрации строк в запросах DML (SELECT/UPDATE/DELETE)">WHERE</span>.</p><div class="code-block" data-lang="sql">
UPDATE tablename 
SET column1 = 'new_value' 
WHERE column2 = 'condition';
</div><p id="tw29xn_39"><span class="tooltip" id="tw29xn_50" title="Оператор удаления строк из таблицы по условию">DELETE</span> удаляет строки, удовлетворяющие условию.</p><div class="code-block" data-lang="sql">
DELETE FROM tablename 
WHERE column1 = 'condition';
</div><p id="tw29xn_41"><span class="tooltip" id="tw29xn_51" title="Оператор создания объектов БД (баз, схем, таблиц, индексов, представлений)">CREATE</span> создаёт объекты (таблицы, базы), <span class="tooltip" id="tw29xn_52" title="Оператор удаления объектов БД (без возврата без бэкапа)">DROP</span> &mdash; удаляет.</p><div class="code-block" data-lang="sql">
CREATE TABLE tablename (
    column1 datatype,
    column2 datatype
);
</div><div class="code-block" data-lang="sql">
DROP TABLE tablename;
</div><aside class="prompt" data-type="warning" data-title="" id="tw29xn_44"><p id="tw29xn_53"><code class="code" id="tw29xn_54">DROP</code> необратим без резервной копии. Для безопасного удаления используйте <code class="code" id="tw29xn_55">DROP TABLE IF EXISTS</code>.</p></aside><section class="chapter"><h3 id="tw29xn_45" data-toc="tw29xn_45">Типы данных в PostgreSQL</h3><p id="tw29xn_56">Корректный выбор типов повышает производительность и экономит место. В <span class="tooltip" id="tw29xn_59" title="Объектно-реляционная СУБД с поддержкой JSONB, массивов, CTE, оконных функций и материализованных представлений">PostgreSQL</span> доступны:</p><ul class="list _bullet" id="tw29xn_57"><li class="list__item" id="tw29xn_60"><p><span id="tw29xn_65"><b>Числовые</b></span>: <code class="code" id="tw29xn_66">smallint</code>, <code class="code" id="tw29xn_67">integer</code>, <code class="code" id="tw29xn_68">bigint</code>, <code class="code" id="tw29xn_69">decimal</code>, <code class="code" id="tw29xn_70">numeric</code>.</p></li><li class="list__item" id="tw29xn_61"><p><span id="tw29xn_71"><b>Строковые</b></span>: <code class="code" id="tw29xn_72">varchar</code>, <code class="code" id="tw29xn_73">text</code>, <code class="code" id="tw29xn_74">char</code>.</p></li><li class="list__item" id="tw29xn_62"><p><span id="tw29xn_75"><b>Дата и время</b></span>: <code class="code" id="tw29xn_76">date</code>, <code class="code" id="tw29xn_77">time</code>, <code class="code" id="tw29xn_78">timestamp</code>.</p></li><li class="list__item" id="tw29xn_63"><p><span id="tw29xn_79"><b>Логический</b></span>: <code class="code" id="tw29xn_80">boolean</code>.</p></li><li class="list__item" id="tw29xn_64"><p><span id="tw29xn_81"><b>Структурированные</b></span>: <code class="code" id="tw29xn_82">json</code>, <code class="code" id="tw29xn_83">jsonb</code>, массивы <code class="code" id="tw29xn_84">[]</code>.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="tw29xn_58"><p id="tw29xn_85"><code class="code" id="tw29xn_86">jsonb</code> предпочтителен для индексации и поиска по ключам JSON.</p></aside></section></section><section class="chapter"><h2 id="tw29xn_6" data-toc="tw29xn_6">Операции с данными</h2><ul class="list _bullet" id="tw29xn_87"><li class="list__item" id="tw29xn_89"><p id="tw29xn_92"><span class="control" id="tw29xn_94">Фильтрация</span>: Используется оператор <code class="code" id="tw29xn_95">WHERE</code>.</p><div class="code-block" data-lang="sql">
SELECT * 
FROM tablename 
WHERE column1 = 'condition';
</div></li><li class="list__item" id="tw29xn_90"><p id="tw29xn_96"><span class="control" id="tw29xn_98">Сортировка</span>: Используется оператор <code class="code" id="tw29xn_99">ORDER BY</code>.</p><div class="code-block" data-lang="sql">
SELECT * 
FROM tablename 
ORDER BY column1 ASC/DESC;
</div></li><li class="list__item" id="tw29xn_91"><p id="tw29xn_100"><span class="control" id="tw29xn_102">Группировка</span>: Используется оператор <code class="code" id="tw29xn_103">GROUP BY</code>.</p><div class="code-block" data-lang="sql">
SELECT column1, SUM(column2) 
FROM tablename 
GROUP BY column1;
</div></li></ul><aside class="prompt" data-type="warning" data-title="" id="tw29xn_88"><p id="tw29xn_104">В <code class="code" id="tw29xn_105">SELECT</code> должны быть либо агрегатные функции, либо поля из <code class="code" id="tw29xn_106">GROUP BY</code>.</p></aside></section><section class="chapter"><h2 id="tw29xn_7" data-toc="tw29xn_7">Транзакции и индексы</h2><p id="tw29xn_107"><span class="tooltip" id="tw29xn_112" title="Атомарная последовательность операций над данными (ACID), завершающаяся полностью или откатывающаяся">Транзакция</span> объединяет несколько операций в одно целое: либо все успешны, либо ни одна. Это сохраняет целостность данных.</p><div class="code-block" data-lang="sql">
BEGIN;
-- операции
COMMIT;
</div><p id="tw29xn_109"><span class="tooltip" id="tw29xn_113" title="Позиция элемента в массиве или символа в строке, начиная с нуля">Индекс</span> ускоряет поиск и сортировку по столбцам.</p><div class="code-block" data-lang="sql">
CREATE INDEX indexname
 ON tablename (columnname);
</div><aside class="prompt" data-type="warning" data-title="" id="tw29xn_111"><p id="tw29xn_114">Индексы ускоряют чтение, но замедляют запись (INSERT/UPDATE/DELETE). Индексируйте избирательно.</p></aside></section><section class="chapter"><h2 id="tw29xn_8" data-toc="tw29xn_8">Практические примеры</h2><ul class="list _bullet" id="tw29xn_115"><li class="list__item" id="tw29xn_118"><p id="tw29xn_121"><span class="control" id="tw29xn_123">Создание базы данных и таблицы</span>:</p><div class="code-block" data-lang="sql">
CREATE DATABASE mydatabase;
\c mydatabase
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100)
);
</div></li><li class="list__item" id="tw29xn_119"><p id="tw29xn_124"><span class="control" id="tw29xn_126">Добавление данных</span>:</p><div class="code-block" data-lang="sql">
INSERT INTO users (name, email) 
VALUES ('John Doe', 'john@example.com');
</div></li><li class="list__item" id="tw29xn_120"><p id="tw29xn_127"><span class="control" id="tw29xn_129">Выборка данных</span>:</p><div class="code-block" data-lang="sql">
SELECT * FROM users WHERE name = 'John Doe';
</div></li></ul><aside class="prompt" data-type="note" data-title="" id="tw29xn_116"><p id="tw29xn_130"><code class="code" id="tw29xn_131">SERIAL</code> &mdash; удобный способ создать автоинкрементный идентификатор; под капотом используется последовательность.</p></aside><ul class="list _bullet" id="tw29xn_117"><li class="list__item" id="tw29xn_132"></li></ul></section><section class="chapter"><h2 id="tw29xn_9" data-toc="tw29xn_9">Подзапросы и соединения</h2><section class="chapter"><h3 id="tw29xn_133" data-toc="tw29xn_133">Подзапросы</h3><p id="tw29xn_135"><span class="tooltip" id="tw29xn_137" title="Вложенный SELECT, результат которого используется во внешнем запросе">Подзапрос</span> &mdash; вложенный <code class="code" id="tw29xn_138">SELECT</code>, который возвращает значение(я) для условия во внешнем запросе.</p><div class="code-block" data-lang="sql">
SELECT *
FROM users
WHERE salary &gt; (SELECT AVG(salary) FROM users);
</div></section><section class="chapter"><h3 id="tw29xn_134" data-toc="tw29xn_134">Соединения</h3><p id="tw29xn_139">Соединения объединяют строки из двух таблиц по условию соответствия ключей.</p><section class="chapter"><h4 id="inner-join" data-toc="inner-join">INNER JOIN</h4><p id="tw29xn_144">Возвращает только те строки, которые имеют совпадения в обеих таблицах.</p><div class="code-block" data-lang="sql">
SELECT *
FROM users
         INNER JOIN orders
                    ON users.id = orders.user_id;
</div></section><section class="chapter"><h4 id="left-join" data-toc="left-join">LEFT JOIN</h4><p id="tw29xn_146">Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если нет совпадений, возвращает NULL.</p><div class="code-block" data-lang="sql">
SELECT *
FROM users
         LEFT JOIN orders
                   ON users.id = orders.user_id;
</div></section><section class="chapter"><h4 id="right-join" data-toc="right-join">RIGHT JOIN</h4><p id="tw29xn_148">Аналогично LEFT JOIN, но возвращает все строки из правой таблицы.</p><div class="code-block" data-lang="sql">
SELECT *
FROM users
         RIGHT JOIN orders
                    ON users.id = orders.user_id;
</div></section><section class="chapter"><h4 id="full-outer-join" data-toc="full-outer-join">FULL OUTER JOIN</h4><p id="tw29xn_150">Возвращает все строки из обеих таблиц, заполняя NULL там, где нет совпадений.</p><div class="code-block" data-lang="sql">
SELECT *
FROM users
         FULL OUTER JOIN orders
                         ON users.id = orders.user_id;
</div><aside class="prompt" data-type="tip" data-title="" id="tw29xn_152"><p id="tw29xn_153">Используйте <code class="code" id="tw29xn_154">USING (column)</code>, если имя соединяющего столбца совпадает в обеих таблицах.</p></aside></section></section></section><section class="chapter"><h2 id="tw29xn_10" data-toc="tw29xn_10">Агрегатные функции</h2><p id="tw29xn_155">Агрегатные функции используются для вычисления значений на основе набора данных.</p><ul class="list _bullet" id="tw29xn_156"><li class="list__item" id="tw29xn_158"><p id="tw29xn_163"><span class="control" id="tw29xn_164">SUM</span>: Сумма значений.</p></li><li class="list__item" id="tw29xn_159"><p id="tw29xn_165"><span class="control" id="tw29xn_166">AVG</span>: Среднее значение.</p></li><li class="list__item" id="tw29xn_160"><p id="tw29xn_167"><span class="control" id="tw29xn_168">MAX</span>: Максимальное значение.</p></li><li class="list__item" id="tw29xn_161"><p id="tw29xn_169"><span class="control" id="tw29xn_170">MIN</span>: Минимальное значение.</p></li><li class="list__item" id="tw29xn_162"><p id="tw29xn_171"><span class="control" id="tw29xn_172">COUNT</span>: Количество строк.</p></li></ul><div class="code-block" data-lang="sql">
SELECT SUM(salary) AS total_salary
FROM users;
</div></section><section class="chapter"><h2 id="tw29xn_11" data-toc="tw29xn_11">Индексирование и оптимизация запросов</h2><p id="tw29xn_173">Индексирование может существенно повысить скорость выполнения запросов.</p><section class="chapter"><h3 id="tw29xn_174" data-toc="tw29xn_174">Создание индекса</h3><div class="code-block" data-lang="sql">
CREATE INDEX idx_name
    ON users (name);
</div></section><section class="chapter"><h3 id="tw29xn_175" data-toc="tw29xn_175">Оптимизация запросов</h3><ul class="list _bullet" id="tw29xn_177"><li class="list__item" id="tw29xn_179"><p id="tw29xn_182">Используйте <code class="code" id="tw29xn_183">EXPLAIN</code> для анализа плана выполнения запроса.</p></li><li class="list__item" id="tw29xn_180"><p id="tw29xn_184">Избегайте использования <code class="code" id="tw29xn_185">SELECT *</code>, если не нужно все поля.</p></li><li class="list__item" id="tw29xn_181"><p id="tw29xn_186">Используйте индексы для полей, участвующих в фильтрации и сортировке.</p></li></ul><div class="code-block" data-lang="sql">
EXPLAIN
SELECT *
FROM users
WHERE name = 'John Doe';
</div></section></section><section class="chapter"><h2 id="tw29xn_12" data-toc="tw29xn_12">Безопасность и права доступа</h2><section class="chapter"><h3 id="tw29xn_187" data-toc="tw29xn_187">Создание пользователей и назначение прав</h3><p id="tw29xn_189">В PostgreSQL пользователи &mdash; это <span class="tooltip" id="tw29xn_192" title="Пользователь/группа в PostgreSQL, на которую назначаются привилегии доступа">роли</span>. Привилегии выдаются на объекты (таблицы, схемы, БД).</p><div class="code-block" data-lang="sql">
CREATE ROLE myuser WITH PASSWORD 'mypassword';
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE users TO myuser;
</div><aside class="prompt" data-type="warning" data-title="" id="tw29xn_191"><p id="tw29xn_193"><code class="code" id="tw29xn_194">SUPERUSER</code> даёт полный доступ ко всем объектам. Используйте минимум прав по принципу наименьших привилегий.</p></aside></section><section class="chapter"><h3 id="tw29xn_188" data-toc="tw29xn_188">Роли и привилегии</h3><ul class="list _bullet" id="tw29xn_195"><li class="list__item" id="tw29xn_197"><p id="tw29xn_200"><span class="control" id="tw29xn_201">SUPERUSER</span>: Полный доступ к базе данных.</p></li><li class="list__item" id="tw29xn_198"><p id="tw29xn_202"><span class="control" id="tw29xn_203">CREATEDB</span>: Право создавать базы данных.</p></li><li class="list__item" id="tw29xn_199"><p id="tw29xn_204"><span class="control" id="tw29xn_205">CREATEROLE</span>: Право создавать роли.</p></li></ul><div class="code-block" data-lang="sql">
ALTER ROLE myuser WITH SUPERUSER;
</div></section></section><section class="chapter"><h2 id="tw29xn_13" data-toc="tw29xn_13">Резервное копирование и восстановление</h2><section class="chapter"><h3 id="tw29xn_206" data-toc="tw29xn_206">Создание резервной копии</h3><div class="code-block" data-lang="sql">
pg_dump -U myuser mydatabase &gt; backup.sql
</div></section><section class="chapter"><h3 id="tw29xn_207" data-toc="tw29xn_207">Восстановление из резервной копии</h3><div class="code-block" data-lang="sql">
psql -U myuser mydatabase &lt; backup.sql
</div><aside class="prompt" data-type="note" data-title="" id="tw29xn_210"><p id="tw29xn_211">Проверяйте совместимость версий <code class="code" id="tw29xn_212">pg_dump</code> и сервера, а также кодировку базы.</p></aside></section></section><section class="chapter"><h2 id="tw29xn_14" data-toc="tw29xn_14">Триггеры и функции</h2><p id="tw29xn_213"><span class="tooltip" id="tw29xn_217" title="Процедура, автоматически выполняемая при INSERT/UPDATE/DELETE на таблице">Триггер</span> запускает процедуру при событиях <code class="code" id="tw29xn_218">INSERT</code>/<code class="code" id="tw29xn_219">UPDATE</code>/<code class="code" id="tw29xn_220">DELETE</code>.</p><div class="code-block" data-lang="sql">
CREATE OR REPLACE FUNCTION update_timestamp()
    RETURNS TRIGGER AS
$$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_timestamp_trigger
    BEFORE UPDATE
    ON users
    FOR EACH ROW
EXECUTE PROCEDURE update_timestamp();
</div><p id="tw29xn_215">Функции позволяют группировать повторяющиеся операции и использовать их в запросах.</p><div class="code-block" data-lang="sql">
CREATE OR REPLACE FUNCTION get_user_name(p_id INTEGER)
    RETURNS VARCHAR AS
$$
DECLARE
    v_name VARCHAR;
BEGIN
    SELECT name
    INTO v_name
    FROM users
    WHERE id = p_id;
    RETURN v_name;
END;
$$ LANGUAGE plpgsql;

SELECT get_user_name(1);
</div></section><section class="chapter"><h2 id="tw29xn_15" data-toc="tw29xn_15">Последовательности и идентификаторы</h2><section class="chapter"><h3 id="tw29xn_221" data-toc="tw29xn_221">Последовательности</h3><p id="tw29xn_223">Последовательности используются для создания уникальных идентификаторов.</p><div class="code-block" data-lang="sql">
CREATE SEQUENCE user_id_seq;

CREATE TABLE users
(
    id   INTEGER DEFAULT nextval('user_id_seq'),
    name VARCHAR(50)
);
</div></section><section class="chapter"><h3 id="serial" data-toc="serial">Идентификаторы (SERIAL)</h3><p id="tw29xn_225">SERIAL &mdash; это псевдоним для последовательности, который автоматически создается при создании таблицы.</p><div class="code-block" data-lang="sql">
CREATE TABLE users
(
    id   SERIAL PRIMARY KEY,
    name VARCHAR(50)
);
</div></section></section><section class="chapter"><h2 id="tw29xn_16" data-toc="tw29xn_16">Вью и материализованные вью</h2><section class="chapter"><h3 id="tw29xn_227" data-toc="tw29xn_227">Вью</h3><p id="tw29xn_234">Вью &mdash; это виртуальные таблицы, которые основаны на запросе. Они не хранят данные физически, а вместо этого вычисляют результаты запроса каждый раз, когда к ним обращаются.</p><div class="code-block" data-lang="sql">
CREATE VIEW user_info AS
SELECT id, name, email
FROM users;

SELECT *
FROM user_info;
</div></section><section class="chapter"><h3 id="tw29xn_228" data-toc="tw29xn_228">Материализованные вью</h3><p id="tw29xn_236">Материализованные вью &mdash; это физические таблицы, которые периодически обновляются на основе запроса. Они хранят результаты запроса в физической таблице, что может ускорить выполнение запросов.</p><div class="code-block" data-lang="sql">
CREATE MATERIALIZED VIEW user_info AS
SELECT id, name, email
FROM users;

REFRESH MATERIALIZED VIEW user_info;
</div></section><section class="chapter"><h3 id="tw29xn_229" data-toc="tw29xn_229">Пример материализованного представления</h3><section class="chapter"><h4 id="1" data-toc="1">1. Создание исходных таблиц</h4><div class="code-block" data-lang="sql">
-- Таблица продаж
CREATE TABLE sales
(
    id         SERIAL PRIMARY KEY,
    product_id INT,
    sale_date  DATE,
    quantity   INT,
    price      DECIMAL(10, 2)
);

-- Таблица продуктов
CREATE TABLE products
(
    id       SERIAL PRIMARY KEY,
    name     VARCHAR(100),
    category VARCHAR(50)
);

-- Наполнение тестовыми данными
INSERT INTO products (name, category)
VALUES ('Ноутбук', 'Электроника'),
       ('Смартфон', 'Электроника'),
       ('Книга', 'Литература');

INSERT INTO sales (product_id, sale_date, quantity, price)
VALUES (1, '2025-01-01', 5, 100000),
       (2, '2025-01-02', 10, 50000),
       (3, '2025-01-03', 20, 1000);
</div></section><section class="chapter"><h4 id="2" data-toc="2">2. Создание материализованного представления</h4><div class="code-block" data-lang="sql">
CREATE MATERIALIZED VIEW sales_summary AS
SELECT p.category,
       COUNT(s.id)               AS total_sales,
       SUM(s.quantity * s.price) AS total_revenue,
       MAX(s.sale_date)          AS last_sale_date
FROM sales s
         JOIN products p ON s.product_id = p.id
GROUP BY p.category
WITH DATA;
</div></section><section class="chapter"><h4 id="3" data-toc="3">3. Запрос к материализованному представлению</h4><div class="code-block" data-lang="sql">
SELECT *
FROM sales_summary;
</div><div class="table-wrapper"><table class="wide" id="tw29xn_245"><thead><tr class="ijRowHead" id="tw29xn_246"><th id="tw29xn_249"><p>category</p></th><th id="tw29xn_250"><p>total_sales</p></th><th id="tw29xn_251"><p>total_revenue</p></th><th id="tw29xn_252"><p>last_sale_date</p></th></tr></thead><tbody><tr id="tw29xn_247"><td id="tw29xn_253"><p>Электроника</p></td><td id="tw29xn_254"><p>2</p></td><td id="tw29xn_255"><p>1000000</p></td><td id="tw29xn_256"><p>2025-01-02</p></td></tr><tr id="tw29xn_248"><td id="tw29xn_257"><p>Литература</p></td><td id="tw29xn_258"><p>1</p></td><td id="tw29xn_259"><p>20000</p></td><td id="tw29xn_260"><p>2025-01-03</p></td></tr></tbody></table></div></section></section><section class="chapter"><h3 id="tw29xn_230" data-toc="tw29xn_230">Сравнение с обычным запросом</h3><section class="chapter"><h4 id="tw29xn_261" data-toc="tw29xn_261">Обычный агрегирующий запрос:</h4><div class="code-block" data-lang="sql">
EXPLAIN ANALYZE
SELECT p.category,
       COUNT(s.id),
       SUM(s.quantity * s.price),
       MAX(s.sale_date)
FROM sales s
         JOIN products p ON s.product_id = p.id
GROUP BY p.category;
</div><p id="tw29xn_264"><span class="control" id="tw29xn_266">План выполнения:</span></p><div class="code-block" data-lang="none">
GroupAggregate  (cost=30.76..30.79 rows=2 width=68)
Planning Time: 0.153 ms
Execution Time: 0.045 ms
</div></section><section class="chapter"><h4 id="tw29xn_262" data-toc="tw29xn_262">Запрос к материализованному представлению:</h4><div class="code-block" data-lang="sql">
EXPLAIN ANALYZE
SELECT *
FROM sales_summary;
</div><p id="tw29xn_268"><span class="control" id="tw29xn_270">План выполнения:</span></p><div class="code-block" data-lang="none">
Seq Scan on sales_summary  (cost=0.00..1.03 rows=3 width=68)
Planning Time: 0.014 ms
Execution Time: 0.012 ms
</div></section></section><section class="chapter"><h3 id="tw29xn_231" data-toc="tw29xn_231">Ключевые преимущества:</h3><ol class="list _decimal" id="tw29xn_271" type="1"><li class="list__item" id="tw29xn_275"><p id="tw29xn_278"><span class="control" id="tw29xn_279">Производительность</span> Время выполнения сократилось с <span class="control" id="tw29xn_280">0.045 ms</span> до <span class="control" id="tw29xn_281">0.012 ms</span> (в 3.75 раза быстрее). Для больших данных разница будет более существенной.</p></li><li class="list__item" id="tw29xn_276"><p id="tw29xn_282"><span class="control" id="tw29xn_284">Снижение нагрузки на БД</span> Материализованное представление:</p><ul class="list _bullet" id="tw29xn_283"><li class="list__item" id="tw29xn_285"><p id="tw29xn_288">Не требует выполнения JOIN операций</p></li><li class="list__item" id="tw29xn_286"><p id="tw29xn_289">Избегает повторных вычислений агрегатных функций</p></li><li class="list__item" id="tw29xn_287"><p id="tw29xn_290">Минимизирует блокировки таблиц</p></li></ul></li><li class="list__item" id="tw29xn_277"><p id="tw29xn_291"><span class="control" id="tw29xn_292">Возможность индексирования</span></p></li></ol><div class="code-block" data-lang="sql">
CREATE INDEX idx_sales_summary_category ON sales_summary (category);
</div><p id="tw29xn_273">Индексы на материализованных представлениях работают как на обычных таблицах.</p><ol class="list _decimal" id="tw29xn_274" type="1" start="4"><li class="list__item" id="tw29xn_293"><p id="tw29xn_294"><span class="control" id="tw29xn_296">Оптимизация сложных запросов</span><br> Особенно эффективны для:</p><ul class="list _bullet" id="tw29xn_295"><li class="list__item" id="tw29xn_298"><p id="tw29xn_302">Многотабличных JOIN-ов</p></li><li class="list__item" id="tw29xn_299"><p id="tw29xn_303">Вложенных подзапросов</p></li><li class="list__item" id="tw29xn_300"><p id="tw29xn_304">Рекурсивных запросов</p></li><li class="list__item" id="tw29xn_301"><p id="tw29xn_305">Геопространственных вычислений</p></li></ul></li></ol></section><section class="chapter"><h3 id="tw29xn_232" data-toc="tw29xn_232">Ограничения и особенности:</h3><ol class="list _decimal" id="tw29xn_306" type="1"><li class="list__item" id="tw29xn_311"><p id="tw29xn_312"><span class="control" id="tw29xn_313">Обновление данных</span> Требует явного обновления:</p></li></ol><div class="code-block" data-lang="sql">
REFRESH MATERIALIZED VIEW sales_summary; -- Полное обновление
REFRESH MATERIALIZED VIEW CONCURRENTLY sales_summary; -- Без блокировок (PostgreSQL 9.4+)
</div><ol class="list _decimal" id="tw29xn_308" type="1" start="2"><li class="list__item" id="tw29xn_314"><p id="tw29xn_315"><span class="control" id="tw29xn_316">Хранение данных</span> Занимает место на диске (как обычная таблица). Размер можно проверить:</p></li></ol><div class="code-block" data-lang="sql">
SELECT pg_size_pretty(pg_total_relation_size('sales_summary'));
</div><ol class="list _decimal" id="tw29xn_310" type="1" start="3"><li class="list__item" id="tw29xn_317"><p id="tw29xn_318"><span class="control" id="tw29xn_319">Актуальность данных</span> Не отражает изменения в реальном времени. Частота обновления зависит от требований приложения.</p></li></ol></section><section class="chapter"><h3 id="tw29xn_233" data-toc="tw29xn_233">Когда использовать:</h3><ul class="list _bullet" id="tw29xn_320"><li class="list__item" id="tw29xn_322"><p id="tw29xn_326">Отчеты и аналитика, где допустима небольшая задержка данных</p></li><li class="list__item" id="tw29xn_323"><p id="tw29xn_327">Сложные дашборды с агрегацией</p></li><li class="list__item" id="tw29xn_324"><p id="tw29xn_328">Часто используемые ресурсоемкие запросы</p></li><li class="list__item" id="tw29xn_325"><p id="tw29xn_329">Системы с высокой read-нагрузкой</p></li></ul><p id="tw29xn_321">Материализованные представления особенно выгодны при работе с большими объемами данных (от миллионов записей), где обычные агрегационные запросы становятся непозволительно медленными.</p></section></section><section class="chapter"><h2 id="common-table-expressions-cte" data-toc="common-table-expressions-cte">Common Table Expressions (CTE)</h2><p id="tw29xn_330">CTE &mdash; это временные результаты, которые можно использовать в запросе.</p><p id="tw29xn_331">Общие табличные выражения (CTE) позволяют сохранять результаты запроса на этапе построения запроса. CTE объявляются с помощью ключевого слова WITH и могут быть использованы в основном запросе.</p><div class="code-block" data-lang="sql">
WITH user_data AS (SELECT id, name
                   FROM users)
SELECT *
FROM user_data
WHERE name = 'John Doe';
</div></section><section class="chapter"><h2 id="tw29xn_18" data-toc="tw29xn_18">Регулярные выражения</h2><p id="tw29xn_333">Регулярные выражения используются для поиска и замены текста.</p><div class="code-block" data-lang="sql">
SELECT *
FROM users
WHERE name ~ 'John.*';
</div></section><section class="chapter"><h2 id="window-functions" data-toc="window-functions">Окна (Window Functions)</h2><p id="tw29xn_335">Окна, или оконные функции, &mdash; это мощный инструмент SQL, позволяющий выполнять вычисления над набором строк, связанных с текущей строкой. Они позволяют получить доступ к данным из соседних строк, что делает возможным выполнение таких операций, как ранжирование, агрегация и сравнение значений между строками.</p><section class="chapter"><h3 id="tw29xn_336" data-toc="tw29xn_336">Преимущества</h3><ul class="list _bullet" id="tw29xn_340"><li class="list__item" id="tw29xn_341"><p id="tw29xn_344"><span class="control" id="tw29xn_345">Ранжирование и сортировка</span>: Окна позволяют ранжировать строки по определенным критериям.</p></li><li class="list__item" id="tw29xn_342"><p id="tw29xn_346"><span class="control" id="tw29xn_347">Агрегация</span>: Выполняют агрегационные операции над набором строк.</p></li><li class="list__item" id="tw29xn_343"><p id="tw29xn_348"><span class="control" id="tw29xn_349">Сравнение значений</span>: Позволяют сравнивать значения между соседними строками.</p></li></ul></section><section class="chapter"><h3 id="tw29xn_337" data-toc="tw29xn_337">Основные оконные функции</h3><section class="chapter"><h4 id="1-row-number" data-toc="1-row-number">1. <code class="code" id="tw29xn_357">ROW_NUMBER()</code></h4><p id="tw29xn_355">Назначает уникальный номер каждой строке в результате запроса.</p><div class="code-block" data-lang="sql">
SELECT id,
       name,
       ROW_NUMBER() OVER (ORDER BY id) AS row_num
FROM users;
</div></section><section class="chapter"><h4 id="2-rank-dense-rank" data-toc="2-rank-dense-rank">2. <code class="code" id="tw29xn_361">RANK()</code> и <code class="code" id="tw29xn_362">DENSE_RANK()</code></h4><p id="tw29xn_359">Используются для ранжирования строк. <code class="code" id="tw29xn_363">RANK()</code> оставляет пробелы в ранжировании, если есть равные значения, а <code class="code" id="tw29xn_364">DENSE_RANK()</code> не оставляет пробелов.</p><div class="code-block" data-lang="sql">
SELECT id,
       score,
       RANK() OVER (ORDER BY score DESC)       AS rank,
       DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank
FROM scores;
</div></section><section class="chapter"><h4 id="3-lag-lead" data-toc="3-lag-lead">3. <code class="code" id="tw29xn_368">LAG()</code> и <code class="code" id="tw29xn_369">LEAD()</code></h4><p id="tw29xn_366">Позволяют получить доступ к предыдущей (<code class="code" id="tw29xn_370">LAG()</code>) или следующей (<code class="code" id="tw29xn_371">LEAD()</code>) строке.</p><div class="code-block" data-lang="sql">
SELECT id,
       name,
       LAG(name) OVER (ORDER BY id)  AS prev_name,
       LEAD(name) OVER (ORDER BY id) AS next_name
FROM users;
</div></section><section class="chapter"><h4 id="4-sum-avg-max-min" data-toc="4-sum-avg-max-min">4. <code class="code" id="tw29xn_375">SUM()</code>, <code class="code" id="tw29xn_376">AVG()</code>, <code class="code" id="tw29xn_377">MAX()</code>, <code class="code" id="tw29xn_378">MIN()</code></h4><p id="tw29xn_373">Выполняют агрегационные операции над набором строк.</p><div class="code-block" data-lang="sql">
SELECT id,
       name,
       SUM(score) OVER (PARTITION BY category) AS total_score
FROM scores;
</div></section></section><section class="chapter"><h3 id="tw29xn_338" data-toc="tw29xn_338">Ключевые понятия</h3><ul class="list _bullet" id="tw29xn_379"><li class="list__item" id="tw29xn_380"><p id="tw29xn_384"><span class="control" id="tw29xn_385"><code class="code" id="tw29xn_386">OVER</code></span>: Определяет набор строк, над которым выполняется оконная функция.</p></li><li class="list__item" id="tw29xn_381"><p id="tw29xn_387"><span class="control" id="tw29xn_388"><code class="code" id="tw29xn_389">PARTITION BY</code></span>: Разделяет результат на группы по указанным столбцам.</p></li><li class="list__item" id="tw29xn_382"><p id="tw29xn_390"><span class="control" id="tw29xn_391"><code class="code" id="tw29xn_392">ORDER BY</code></span>: Определяет порядок строк внутри каждой группы.</p></li><li class="list__item" id="tw29xn_383"><p id="tw29xn_393"><span class="control" id="tw29xn_394"><code class="code" id="tw29xn_396">ROWS</code> или <code class="code" id="tw29xn_397">RANGE</code></span>: Определяет границы окна (например, <code class="code" id="tw29xn_395">ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</code>).</p></li></ul></section><section class="chapter"><h3 id="tw29xn_339" data-toc="tw29xn_339">Примеры использования</h3><section class="chapter"><h4 id="tw29xn_398" data-toc="tw29xn_398">Ранжирование студентов по баллам</h4><div class="code-block" data-lang="sql">
SELECT student_id,
       score,
       RANK() OVER (ORDER BY score DESC) AS rank
FROM exam_results;
</div></section><section class="chapter"><h4 id="tw29xn_399" data-toc="tw29xn_399">Агрегация продаж по категориям</h4><div class="code-block" data-lang="sql">
SELECT category,
       SUM(amount) OVER (PARTITION BY category) AS total_sales
FROM sales;
</div></section><section class="chapter"><h4 id="tw29xn_400" data-toc="tw29xn_400">Сравнение значений между соседними строками</h4><div class="code-block" data-lang="sql">
SELECT id,
       value,
       LAG(value) OVER (ORDER BY id)  AS prev_value,
       LEAD(value) OVER (ORDER BY id) AS next_value
FROM data;
</div></section></section></section><div class="last-modified">27 сентября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="subd.html" class="navigation-links__prev">СУБД</a><a href="db-theory.html" class="navigation-links__next">Теория (Н, Т, Д)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>