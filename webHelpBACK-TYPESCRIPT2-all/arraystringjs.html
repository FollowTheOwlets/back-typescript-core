<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#C14424" data-link-color="#C14424"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-01T18:55:35.1464936"><title>Методы массивов и строк в JavaScript | Backend Typescript</title><script type="application/json" id="virtual-toc-data">[{"id":"tau4rk_3","level":0,"title":"База: массивы и строки","anchor":"#tau4rk_3"},{"id":"tau4rk_4","level":0,"title":"Как отличать мутабельные и немутирующие методы","anchor":"#tau4rk_4"},{"id":"tau4rk_5","level":0,"title":"Массивы: мутабельные методы (изменяют исходный массив)","anchor":"#tau4rk_5"},{"id":"tau4rk_6","level":0,"title":"Массивы: немутирующие методы (возвращают новый результат)","anchor":"#tau4rk_6"},{"id":"tau4rk_7","level":0,"title":"Перебор массивов и свёртка (ES5)","anchor":"#tau4rk_7"},{"id":"tau4rk_8","level":0,"title":"Строки: поиск и извлечение","anchor":"#tau4rk_8"},{"id":"tau4rk_9","level":0,"title":"Строки: преобразование, замена и разбиение","anchor":"#tau4rk_9"},{"id":"tau4rk_10","level":0,"title":"Массивы ↔ строки: конвертация","anchor":"#tau4rk_10"},{"id":"tau4rk_11","level":0,"title":"Практические рецепты (ES5)","anchor":"#tau4rk_11"},{"id":"tau4rk_12","level":0,"title":"Частые ошибки и лучшие практики","anchor":"#tau4rk_12"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Методы массивов и строк в JavaScript | Backend Typescript"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Backend Typescript Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0.0/arraystringjs.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Методы массивов и строк в JavaScript | Backend Typescript"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0.0/arraystringjs.html#webpage",
    "url": "writerside-documentation//1.0.0/arraystringjs.html",
    "name": "Методы массивов и строк в JavaScript | Backend Typescript",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Backend Typescript Help"
}</script><!-- End Schema.org --></head><body data-id="ArrayStringJs" data-main-title="Методы массивов и строк в JavaScript" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="_JavaScript.topic|JavaScript"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Backend Typescript 1.0.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ArrayStringJs" id="ArrayStringJs.topic">Методы массивов и строк в JavaScript</h1><p id="tau4rk_2">В JavaScript (ES5) для работы с <span class="tooltip" id="tau4rk_13" title="Упорядоченная коллекция значений с индексацией с нуля и свойством length">массивами</span> и <span class="tooltip" id="tau4rk_14" title="Немутируемая последовательность символов в кодировке UTF-16">строками</span> доступен богатый набор методов. Важно понимать, какие методы изменяют исходные данные (<span class="tooltip" id="tau4rk_15" title="Свойство методов изменять исходные данные по месту">мутабельные</span>), а какие возвращают новое значение (<span class="tooltip" id="tau4rk_16" title="Свойство методов возвращать новый результат, не меняя исходные данные">немутирующие</span>), чтобы избегать скрытых ошибок и побочных эффектов.</p><section class="chapter"><h2 id="tau4rk_3" data-toc="tau4rk_3">База: массивы и строки</h2><p id="tau4rk_17"><span id="tau4rk_20"><b>Массив</b></span> &mdash; упорядоченная коллекция значений с <span class="tooltip" id="tau4rk_21" title="Позиция элемента в массиве или символа в строке, начиная с нуля">индексацией</span> с нуля, размер в свойстве <code class="code" id="tau4rk_22">length</code>. Элементы можно изменять по индексу.</p><p id="tau4rk_18"><span id="tau4rk_23"><b>Строка</b></span> &mdash; последовательность символов в <span class="tooltip" id="tau4rk_24" title="Кодировка, в которой JavaScript хранит строки">UTF-16</span>. Строки <span id="tau4rk_25"><b>немутируемые</b></span>: любые &laquo;изменяющие&raquo; операции возвращают новую строку.</p><aside class="prompt" data-type="note" data-title="" id="tau4rk_19"><p id="tau4rk_26">Если нужно изменить строку &laquo;по месту&raquo;, фактически создаётся новая строка. Это важно учитывать при работе с большими текстами.</p></aside></section><section class="chapter"><h2 id="tau4rk_4" data-toc="tau4rk_4">Как отличать мутабельные и немутирующие методы</h2><ul class="list _bullet" id="tau4rk_27"><li class="list__item" id="tau4rk_29"><p>У массивов мутабельные: <code class="code" id="tau4rk_32">push</code>, <code class="code" id="tau4rk_33">pop</code>, <code class="code" id="tau4rk_34">shift</code>, <code class="code" id="tau4rk_35">unshift</code>, <code class="code" id="tau4rk_36">splice</code>, <code class="code" id="tau4rk_37">sort</code>, <code class="code" id="tau4rk_38">reverse</code>.</p></li><li class="list__item" id="tau4rk_30"><p>У массивов немутирующие: <code class="code" id="tau4rk_39">slice</code>, <code class="code" id="tau4rk_40">concat</code>, <code class="code" id="tau4rk_41">map</code>, <code class="code" id="tau4rk_42">filter</code>, <code class="code" id="tau4rk_43">reduce</code>/<code class="code" id="tau4rk_44">reduceRight</code>, <code class="code" id="tau4rk_45">every</code>, <code class="code" id="tau4rk_46">some</code>, <code class="code" id="tau4rk_47">indexOf</code>/<code class="code" id="tau4rk_48">lastIndexOf</code>, <code class="code" id="tau4rk_49">join</code>, <code class="code" id="tau4rk_50">forEach</code> (не меняет сам массив, если не делать этого явно).</p></li><li class="list__item" id="tau4rk_31"><p>У строк все методы возвращают новую строку: <code class="code" id="tau4rk_51">slice</code>, <code class="code" id="tau4rk_52">substring</code>, <code class="code" id="tau4rk_53">substr</code>, <code class="code" id="tau4rk_54">toUpperCase</code>/<code class="code" id="tau4rk_55">toLowerCase</code>, <code class="code" id="tau4rk_56">trim</code>, <code class="code" id="tau4rk_57">replace</code>, <code class="code" id="tau4rk_58">split</code> и др.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="tau4rk_28"><p id="tau4rk_59">Если поведение метода сомнительно, проверьте, возвращает ли он новое значение и что происходит с исходными данными.</p></aside></section><section class="chapter"><h2 id="tau4rk_5" data-toc="tau4rk_5">Массивы: мутабельные методы (изменяют исходный массив)</h2><ul class="list _bullet" id="tau4rk_60"><li class="list__item" id="tau4rk_65"><p><code class="code" id="tau4rk_72">push(value1, ...)</code> &mdash; добавить в конец, вернуть новую длину.</p></li><li class="list__item" id="tau4rk_66"><p><code class="code" id="tau4rk_73">pop()</code> &mdash; удалить последний элемент, вернуть удалённый.</p></li><li class="list__item" id="tau4rk_67"><p><code class="code" id="tau4rk_74">unshift(value1, ...)</code> &mdash; добавить в начало, вернуть новую длину.</p></li><li class="list__item" id="tau4rk_68"><p><code class="code" id="tau4rk_75">shift()</code> &mdash; удалить первый элемент, вернуть удалённый.</p></li><li class="list__item" id="tau4rk_69"><p><code class="code" id="tau4rk_76">splice(start, deleteCount, item1, ...)</code> &mdash; удалить/вставить по индексу.</p></li><li class="list__item" id="tau4rk_70"><p><code class="code" id="tau4rk_77">sort(compareFn)</code> &mdash; сортировать по месту.</p></li><li class="list__item" id="tau4rk_71"><p><code class="code" id="tau4rk_78">reverse()</code> &mdash; развернуть порядок элементов.</p></li></ul><div class="code-block" data-lang="none">


var a = [3, 1, 2];
a.push(4);
console.log(a); // [3, 1, 2, 4]

a.splice(1, 1, &quot;x&quot;);
console.log(a); // [3, &quot;x&quot;, 2, 4]

var b = [10, 2, 5];
b.sort();
// лексикографическая сортировка как строк
console.log(b); // [10, 2, 5]

b.sort(function (x, y) { return x - y; });
console.log(b); // [2, 5, 10] </div><aside class="prompt" data-type="warning" data-title="" id="tau4rk_62"><p id="tau4rk_79"><code class="code" id="tau4rk_80">sort()</code> без <span class="tooltip" id="tau4rk_81" title="Функция compareFn(a, b) для sort, возвращающая отрицательное/нулевое/положительное число">сравнивающей функции</span> сортирует <span class="tooltip" id="tau4rk_82" title="Порядок сравнения значений как строк по символам">лексикографически</span>. Для чисел почти всегда пишите <code class="code" id="tau4rk_83">function (a, b) { return a - b; }</code>.</p></aside><aside class="prompt" data-type="warning" data-title="" id="tau4rk_63"><p id="tau4rk_84"><code class="code" id="tau4rk_85">splice()</code> меняет исходный массив. Если нужна копия без изменения источника &mdash; применяйте <code class="code" id="tau4rk_86">slice()</code>.</p></aside><aside class="prompt" data-type="warning" data-title="" id="tau4rk_64"><p id="tau4rk_87">Не используйте <code class="code" id="tau4rk_88">delete arr[i]</code> для удаления: останется <span class="tooltip" id="tau4rk_89" title="Элемент-«дырка», появляющийся после delete, при котором length не уменьшается">пустой элемент</span>, длина не уменьшится. Правильно &mdash; <code class="code" id="tau4rk_90">splice()</code>.</p></aside></section><section class="chapter"><h2 id="tau4rk_6" data-toc="tau4rk_6">Массивы: немутирующие методы (возвращают новый результат)</h2><ul class="list _bullet" id="tau4rk_91"><li class="list__item" id="tau4rk_94"><p><code class="code" id="tau4rk_98">slice(begin, end)</code> &mdash; диапазон [begin, end), поддерживает отрицательные индексы; без аргументов &mdash; поверхностная копия.</p></li><li class="list__item" id="tau4rk_95"><p><code class="code" id="tau4rk_99">concat(valueOrArray, ...)</code> &mdash; склеивает, возвращает новый массив.</p></li><li class="list__item" id="tau4rk_96"><p><code class="code" id="tau4rk_100">indexOf(value, fromIndex)</code>/<code class="code" id="tau4rk_101">lastIndexOf(value, fromIndex)</code> &mdash; поиск, возвращает индекс или <code class="code" id="tau4rk_102">-1</code>.</p></li><li class="list__item" id="tau4rk_97"><p><code class="code" id="tau4rk_103">join(separator)</code> &mdash; массив &rarr; строка с разделителем.</p></li></ul><div class="code-block" data-lang="none">


var src = [{ n: 1 }, { n: 2 }];
var copy = src.slice();
console.log(copy === src); // false
copy[0].n = 99;
console.log(src[0].n); // 99 // поверхностная копия

console.log([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].join(&quot;-&quot;)); // &quot;a-b-c&quot;
console.log([1, 2, 3].indexOf(2)); // 1 </div><aside class="prompt" data-type="tip" data-title="" id="tau4rk_93"><p id="tau4rk_104"><span class="tooltip" id="tau4rk_105" title="Копия структуры, где ссылки на вложенные объекты сохраняются общими">Поверхностная копия</span> сохраняет общие ссылки на вложенные объекты. Меняя вложенный объект, вы меняете его во всех массивах-копиях.</p></aside></section><section class="chapter"><h2 id="tau4rk_7" data-toc="tau4rk_7">Перебор массивов и свёртка (ES5)</h2><ul class="list _bullet" id="tau4rk_106"><li class="list__item" id="tau4rk_110"><p><code class="code" id="tau4rk_116">forEach(callback, thisArg)</code> &mdash; перебрать элементы ради <span class="tooltip" id="tau4rk_117" title="Внешнее воздействие функции (логирование, изменение внешних переменных, I/O)">побочных эффектов</span>.</p></li><li class="list__item" id="tau4rk_111"><p><code class="code" id="tau4rk_118">map(callback, thisArg)</code> &mdash; преобразовать каждый элемент, вернуть новый массив.</p></li><li class="list__item" id="tau4rk_112"><p><code class="code" id="tau4rk_119">filter(callback, thisArg)</code> &mdash; оставить элементы, где <span class="tooltip" id="tau4rk_120" title="Функция, возвращающая true/false для проверки условия">предикат</span> вернул <code class="code" id="tau4rk_121">true</code>.</p></li><li class="list__item" id="tau4rk_113"><p><code class="code" id="tau4rk_122">every(callback, thisArg)</code> &mdash; проверка &laquo;все соответствуют условию&raquo;.</p></li><li class="list__item" id="tau4rk_114"><p><code class="code" id="tau4rk_123">some(callback, thisArg)</code> &mdash; проверка &laquo;хотя бы один соответствует&raquo;.</p></li><li class="list__item" id="tau4rk_115"><p><code class="code" id="tau4rk_124">reduce(callback, initialValue)</code>/<code class="code" id="tau4rk_125">reduceRight(...)</code> &mdash; свёртка к одному значению через <span class="tooltip" id="tau4rk_126" title="Промежуточный накопленный результат в методах reduce/reduceRight">аккумулятор</span>.</p></li></ul><div class="code-block" data-lang="none">


var arr = [1, 2, 3, 4];
arr.forEach(function (x) { console.log(x); }); // 1 2 3 4

var squares = arr.map(function (x) { return x \* x; });
console.log(squares); // [1, 4, 9, 16]

var evens = arr.filter(function (x) { return x % 2 === 0; });
console.log(evens); // [2, 4]

console.log(arr.every(function (x) { return x &gt; 0; })); // true
console.log(arr.some(function (x) { return x &gt; 3; })); // true

var sum = arr.reduce(function (acc, x) { return acc + x; }, 0);
console.log(sum); // 10 </div><aside class="prompt" data-type="warning" data-title="" id="tau4rk_108"><p id="tau4rk_127"><code class="code" id="tau4rk_128">reduce()</code> без <code class="code" id="tau4rk_129">initialValue</code> бросит ошибку на пустом массиве. Всегда задавайте начальное значение (например, <code class="code" id="tau4rk_130">0</code> для суммы).</p></aside><aside class="prompt" data-type="note" data-title="" id="tau4rk_109"><p id="tau4rk_131"><code class="code" id="tau4rk_132">forEach()</code> нельзя прервать <code class="code" id="tau4rk_133">return</code>/<code class="code" id="tau4rk_134">break</code>. Нужен ранний выход &mdash; используйте обычный <code class="code" id="tau4rk_135">for</code> или <code class="code" id="tau4rk_136">some()</code>/<code class="code" id="tau4rk_137">every()</code>.</p></aside></section><section class="chapter"><h2 id="tau4rk_8" data-toc="tau4rk_8">Строки: поиск и извлечение</h2><ul class="list _bullet" id="tau4rk_138"><li class="list__item" id="tau4rk_141"><p><code class="code" id="tau4rk_146">indexOf(substr, fromIndex)</code>/<code class="code" id="tau4rk_147">lastIndexOf(substr, fromIndex)</code> &mdash; поиск подстроки, регистр учитывается.</p></li><li class="list__item" id="tau4rk_142"><p><code class="code" id="tau4rk_148">slice(begin, end)</code> &mdash; подстрока [begin, end), поддерживает отрицательные индексы.</p></li><li class="list__item" id="tau4rk_143"><p><code class="code" id="tau4rk_149">substring(begin, end)</code> &mdash; подстрока, отрицательные считаются как 0; если begin &gt; end &mdash; аргументы меняются местами.</p></li><li class="list__item" id="tau4rk_144"><p><code class="code" id="tau4rk_150">substr(start, length)</code> &mdash; подстрока по старту и длине (доступно в ES5).</p></li><li class="list__item" id="tau4rk_145"><p><code class="code" id="tau4rk_151">charAt(index)</code>/<code class="code" id="tau4rk_152">charCodeAt(index)</code> &mdash; символ и его код (0&ndash;65535).</p></li></ul><div class="code-block" data-lang="none">


var s = &quot;JavaScript&quot;;
console.log(s.indexOf(&quot;Script&quot;)); // 4
console.log(s.slice(4)); // &quot;Script&quot;
console.log(s.substring(4, 10)); // &quot;Script&quot;
console.log(s.substr(4, 6)); // &quot;Script&quot;
console.log(s.charAt(0)); // &quot;J&quot;
console.log(s.charCodeAt(0)); // 74 </div><aside class="prompt" data-type="warning" data-title="" id="tau4rk_140"><p id="tau4rk_153"><code class="code" id="tau4rk_154">slice()</code> и <code class="code" id="tau4rk_155">substring()</code> по-разному трактуют отрицательные индексы. Нужны отрицательные &mdash; используйте <code class="code" id="tau4rk_156">slice()</code>.</p></aside></section><section class="chapter"><h2 id="tau4rk_9" data-toc="tau4rk_9">Строки: преобразование, замена и разбиение</h2><ul class="list _bullet" id="tau4rk_157"><li class="list__item" id="tau4rk_162"><p><code class="code" id="tau4rk_166">toUpperCase()</code>/<code class="code" id="tau4rk_167">toLowerCase()</code> &mdash; изменение регистра (возвращают новую строку).</p></li><li class="list__item" id="tau4rk_163"><p><code class="code" id="tau4rk_168">trim()</code> &mdash; удаляет пробелы по краям.</p></li><li class="list__item" id="tau4rk_164"><p><code class="code" id="tau4rk_169">replace(search, replacement)</code> &mdash; заменяет первое вхождение; для глобальной замены используйте <span class="tooltip" id="tau4rk_170" title="Шаблон для поиска и замены в строках, поддерживаемый методом replace и split">регулярное выражение</span> с флагом <code class="code" id="tau4rk_171">g</code>.</p></li><li class="list__item" id="tau4rk_165"><p><code class="code" id="tau4rk_172">split(separator, limit)</code> &mdash; разбивает строку в массив по <span class="tooltip" id="tau4rk_173" title="Символ(ы), по которому выполняется split/join">разделителю</span>.</p></li></ul><div class="code-block" data-lang="none">


var s = &quot;  hello, world  &quot;;
console.log(s.trim()); // &quot;hello, world&quot;

console.log(&quot;a,b,c&quot;.split(&quot;,&quot;)); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

console.log(&quot;foo foo&quot;.replace(/foo/g, &quot;bar&quot;)); // &quot;bar bar&quot; </div><aside class="prompt" data-type="note" data-title="" id="tau4rk_159"><p id="tau4rk_174">&laquo;Перевернуть&raquo; строку можно так: <code class="code" id="tau4rk_175">split(&quot;&quot;)</code> &rarr; <code class="code" id="tau4rk_176">reverse()</code> &rarr; <code class="code" id="tau4rk_177">join(&quot;&quot;)</code>.</p></aside><div class="code-block" data-lang="none">


var t = &quot;abc&quot;;
var r = t.split(&quot;&quot;).reverse().join(&quot;&quot;);
console.log(r); // &quot;cba&quot; </div><aside class="prompt" data-type="warning" data-title="" id="tau4rk_161"><p id="tau4rk_178">Разворот через <code class="code" id="tau4rk_179">split(&quot;&quot;)</code> ломает символы, кодирующиеся как <span class="tooltip" id="tau4rk_180" title="Пара 16-битных кодовых единиц UTF-16, представляющая один символ вне базовой плоскости">суррогатные пары</span> в UTF-16 (некоторые эмодзи, иероглифы). В ES5 нет простого безопасного решения.</p></aside></section><section class="chapter"><h2 id="tau4rk_10" data-toc="tau4rk_10">Массивы &harr; строки: конвертация</h2><p id="tau4rk_181"><code class="code" id="tau4rk_183">split()</code> превращает строку в массив, а <code class="code" id="tau4rk_184">join()</code> &mdash; массив в строку. Следите за выбранным разделителем, чтобы корректно собирать/разбирать данные.</p><div class="code-block" data-lang="none">
var csv = &quot;1;2;3&quot;;
var arr = csv.split(&quot;;&quot;);
console.log(arr); // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]

var back = arr.join(&quot;;&quot;);
console.log(back); // &quot;1;2;3&quot; </div></section><section class="chapter"><h2 id="tau4rk_11" data-toc="tau4rk_11">Практические рецепты (ES5)</h2><ul class="list _bullet" id="tau4rk_185"><li class="list__item" id="tau4rk_191"><p><span id="tau4rk_192"><b>Удалить дубликаты</b></span> простым способом:</p></li></ul><div class="code-block" data-lang="none">
var a = [1, 2, 2, 3];
var unique = a.filter(function (x, i) { return a.indexOf(x) === i; });
console.log(unique); // [1, 2, 3]
    </div><ul class="list _bullet" id="tau4rk_187"><li class="list__item" id="tau4rk_193"><p><span id="tau4rk_194"><b>Безопасная сортировка чисел</b></span>:</p></li></ul><div class="code-block" data-lang="none">


var nums = [10, 1, 5];
nums.sort(function (a, b) { return a - b; });
console.log(nums); // [1, 5, 10] </div><ul class="list _bullet" id="tau4rk_189"><li class="list__item" id="tau4rk_195"><p><span id="tau4rk_196"><b>Сумма значений через reduce</b></span> (с начальными значениями):</p></li></ul><div class="code-block" data-lang="none">


var empty = [];
var s = empty.reduce(function (acc, x) { return acc + x; }, 0);
console.log(s); // 0 </div></section><section class="chapter"><h2 id="tau4rk_12" data-toc="tau4rk_12">Частые ошибки и лучшие практики</h2><aside class="prompt" data-type="warning" data-title="" id="tau4rk_197"><p id="tau4rk_202">Удаление через <code class="code" id="tau4rk_203">delete arr[i]</code> создаёт &laquo;дырки&raquo;. Правильно удалять элементы массивов &mdash; <code class="code" id="tau4rk_204">splice()</code>.</p></aside><aside class="prompt" data-type="warning" data-title="" id="tau4rk_198"><p id="tau4rk_205">Сортировка без компаратора приводит к лексикографическому порядку. Для чисел задавайте <code class="code" id="tau4rk_206">function (a, b) { return a - b; }</code>.</p></aside><aside class="prompt" data-type="warning" data-title="" id="tau4rk_199"><p id="tau4rk_207"><code class="code" id="tau4rk_208">reduce()</code> без <code class="code" id="tau4rk_209">initialValue</code> падает на пустых массивах. Всегда задавайте начальное значение.</p></aside><aside class="prompt" data-type="note" data-title="" id="tau4rk_200"><p id="tau4rk_210">Для проверки наличия значения в массиве в ES5 используйте <code class="code" id="tau4rk_211">indexOf(x) !== -1</code>. Метод <code class="code" id="tau4rk_212">includes()</code> появился позже.</p></aside><aside class="prompt" data-type="note" data-title="" id="tau4rk_201"><p id="tau4rk_213">Для производительности в &laquo;горячих&raquo; циклах предпочтителен обычный <code class="code" id="tau4rk_214">for</code>, но для читаемости используйте <code class="code" id="tau4rk_215">map</code>/<code class="code" id="tau4rk_216">filter</code>/<code class="code" id="tau4rk_217">reduce</code>, когда это уместно.</p></aside></section><div class="last-modified">24 сентября 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="javascript-es5.html" class="navigation-links__prev">Основы JavaScript ES5</a><a href="es6.html" class="navigation-links__next">Изменения в ES6 после ES5</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>