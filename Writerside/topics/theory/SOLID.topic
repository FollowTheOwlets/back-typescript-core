<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="SOLID" id="SOLID">

    <chapter title="Принципы SOLID и их связь с ООП">
        <p>
            <format style="bold">SOLID</format>
            — это набор пяти принципов проектирования объектно-ориентированных систем. Они формулируют, как правильно
            применять базовые возможности ООП: наследование, инкапсуляцию, полиморфизм и абстракцию. Фактически,
            <tooltip term="SOLID">SOLID</tooltip>
            — это мост между «теорией» объектно-ориентированного подхода и «практикой» написания гибкого и
            поддерживаемого кода.
        </p>
        <note>Вы можете воспринимать SOLID как «развернутую инструкцию», которая объясняет, как использовать ООП так,
            чтобы код был понятным, расширяемым и устойчивым к изменениям.
        </note>
        <chapter title="S — Single Responsibility Principle (Принцип единственной ответственности)">
            <p> Каждый класс должен отвечать только за одну задачу. Этот принцип напрямую связан с
                <tooltip term="Инкапсуляция">инкапсуляцией</tooltip>
                : скрывая детали реализации, мы выделяем чёткие зоны ответственности.
            </p>
            <list>
                <li>ООП даёт инструмент —
                    <tooltip term="Класс">класс</tooltip>
                    .
                </li>
                <li>SOLID уточняет: класс должен инкапсулировать одну ответственность, а не десятки.</li>
            </list>
            <warning>Класс, у которого слишком много обязанностей («God Object»), нарушает SRP. Такие классы трудно
                тестировать, сопровождать и менять.
            </warning>
            <tip>Чтобы проверить, нарушаете ли вы SRP, задайте вопрос: «Если изменится бизнес-правило X, изменится ли
                этот класс?» Если ответ «да» для нескольких несвязанных правил — ответственность раздвоена.
            </tip>
            <p>Схема для SRP:</p>
            <img src="srp.png" alt="Принцип SRP"/>
        </chapter>
        <chapter title="O — Open/Closed Principle (Принцип открытости-закрытости)">
            <p> Программные сущности должны быть
                <format style="bold">открыты для расширения</format>
                , но
                <format style="bold">закрыты для изменения</format>
                . Это прямое следствие
                <tooltip term="Абстракция">абстракции</tooltip>
                и
                <tooltip term="Полиморфизм">полиморфизма</tooltip>
                .
            </p>
            <list>
                <li>ООП даёт нам
                    <tooltip term="Интерфейс">интерфейсы</tooltip>
                    и
                    <tooltip term="Абстрактный класс">абстрактные классы</tooltip>
                    .
                </li>
                <li>SOLID говорит: расширяйте поведение через новые реализации, а не меняйте старый код.</li>
            </list>
            <note>Например, если нужно добавить новый тип фигуры (Треугольник), мы создаём новый класс, реализующий
                интерфейс Shape, а не меняем уже существующие классы.
            </note>
            <p>Схема для OCP:</p>
            <img src="ocp.png" alt="Принцип OCP"/>
        </chapter>
        <chapter title="L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)">
            <p> Подклассы должны быть взаимозаменяемы с базовыми классами. Этот принцип уточняет, как использовать
                <format style="bold">наследование</format>
                . Если класс <code>B</code> наследуется от класса <code>A</code>, то любой код, работающий с
                <code>A</code>, должен корректно работать и с <code>B</code>.
            </p>
            <list>
                <li>ООП даёт наследование и полиморфизм.</li>
                <li>SOLID требует: наследование должно сохранять инварианты и ожидания базового класса.</li>
            </list>
            <warning>Если подкласс нарушает контракты родителя (например, <code>Square extends Rectangle</code>, но
                ломает логику ширины и высоты), то нарушается принцип Лисков.
            </warning>
            <note>Для практики: тестируйте подклассы так, как будто это объекты базового класса. Если что-то ломается —
                принцип нарушен.
            </note>
            <p>Схема для LSP:</p>
            <img src="lsp.png" alt="Принцип LSP"/>
        </chapter>
        <chapter title="I — Interface Segregation Principle (Принцип разделения интерфейсов)">
            <p> Клиенты не должны зависеть от методов, которые они не используют. Это расширение идеи
                <tooltip term="Абстракция">абстракции</tooltip>
                и
                <tooltip term="Интерфейс">интерфейсов</tooltip>
                .
            </p>
            <list>
                <li>ООП позволяет объявлять интерфейсы или абстрактные классы.</li>
                <li>SOLID говорит: делите их на небольшие, специализированные интерфейсы.</li>
            </list>
            <warning>Большие интерфейсы (например, «God Interface») заставляют клиентов реализовывать ненужные методы.
                Это ведёт к «пустым» или фиктивным реализациям.
            </warning>
            <note>Лучше несколько мелких интерфейсов, чем один универсальный. Например, разделяйте <code>Printer</code>
                и <code>Scanner</code> вместо <code>IMultiFunctionDevice</code>.
            </note>
            <p>Схема для ISP:</p>
            <img src="isp.png" alt="Принцип ISP"/>
        </chapter>
        <chapter title="D — Dependency Inversion Principle (Принцип инверсии зависимостей)">
            <p> Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа должны зависеть от
                абстракций. Это развитие идеи
                <tooltip term="Полиморфизм">полиморфизма</tooltip>
                и
                <tooltip term="Инкапсуляция">инкапсуляции</tooltip>
                .
            </p>
            <list>
                <li>ООП даёт абстракции (интерфейсы, базовые классы).</li>
                <li>SOLID формулирует: связывайтесь через абстракцию, а не через конкретику.</li>
            </list>
            <note>Пример: контроллер обращается к <code>Repository</code> через интерфейс, а не напрямую к конкретной
                базе данных. Тогда заменить хранилище можно без переписывания контроллера.
            </note>
            <p>Схема для DIP:</p>
            <img src="dip.png" alt="Принцип DIP"/>
        </chapter>
        <chapter title="Вывод: ООП → SOLID и обратно">
            <p> SOLID не вводит новых сущностей, которых нет в ООП. Он лишь уточняет,
                <format style="bold">как правильно применять ООП</format>
                . Принципы ООП дают инструменты: классы, объекты, наследование, инкапсуляцию, полиморфизм. Принципы
                SOLID говорят, как пользоваться этими инструментами, чтобы избежать ошибок.
            </p>
            <list>
                <li>
                    <format style="bold">SRP</format>
                    — уточнение инкапсуляции: каждая капсула должна содержать одну ответственность.
                </li>
                <li>
                    <format style="bold">OCP</format>
                    — уточнение абстракции: расширяйте через новые реализации, а не меняйте старые.
                </li>
                <li>
                    <format style="bold">LSP</format>
                    — уточнение наследования: наследники не должны ломать поведение родителей.
                </li>
                <li>
                    <format style="bold">ISP</format>
                    — уточнение интерфейсов: делайте маленькие и специализированные интерфейсы.
                </li>
                <li>
                    <format style="bold">DIP</format>
                    — уточнение полиморфизма: связывайтесь через абстракции, а не через конкретные классы.
                </li>
            </list>
            <tip>ООП даёт фундамент, SOLID — практические правила. Вместе они образуют устойчивый стиль
                проектирования.
            </tip>
        </chapter>
    </chapter>
</topic>