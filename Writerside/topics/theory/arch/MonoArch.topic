<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Монолитная архитектура" id="MonoArch">
        <chapter title="Что такое монолит">
            <p><format style="bold">Монолитное приложение</format> — это единый развёртываемый артефакт (один процесс, одна кодовая база и, как правило, один пакет поставки), в котором все подсистемы (интерфейс, доменная логика, интеграции, доступ к данным) размещены вместе. Монолит может быть примитивным «всё-под-одной-крышей» или дисциплинированным <tooltip term="Модульный монолит">модульным монолитом</tooltip> с чёткими границами модулей.</p>
            <note>Монолит — это не «антимикросервисы». Это архитектурная форма с собственными сильными и слабыми сторонами и сценариями уместности.</note>
        </chapter>

        <chapter title="Сильные стороны">
            <list>
                <li><format style="bold">Простота разработки и отладки.</format> Одна кодовая база, единый рантайм и стек. Локальный запуск полностью имитирует продакшн-контекст.</li>
                <li><format style="bold">Согласованность данных по умолчанию.</format> Границы <tooltip term="Транзакция">транзакций</tooltip> легко провести в рамках одной БД, проще реализовать инварианты.</li>
                <li><format style="bold">Простая поставка.</format> Один артефакт — меньше движущихся частей в CI/CD, стандартные стратегии релизов (blue/green, canary) применяются тривиально.</li>
                <li><format style="bold">Более низкие накладные расходы.</format> Нет межсервисной сетевой латентности и сериализации — меньше расходов на инфраструктуру и эксплуатацию.</li>
            </list>
        </chapter>

        <chapter title="Слабые стороны">
            <list>
                <li><format style="bold">Риск эрозии границ.</format> При слабой дисциплине модули «протекают», образуя <tooltip term="Big Ball of Mud">«большой ком грязи»</tooltip>.</li>
                <li><format style="bold">Масштабирование целиком.</format> Горизонтальное масштабирование зачастую вынуждено тащить весь код, даже если горячая только малая часть.</li>
                <li><format style="bold">Замедление сборки и тестов.</format> Рост кодовой базы увеличивает время сборки, запуска тестов и обратной связи.</li>
                <li><format style="bold">Сложности параллельной работы больших команд.</format> Высокие риски конфликтов при мерджах и каскадных изменений.</li>
            </list>
            <warning>Слабые границы модулей приводят к хрупким зависимостям и «сквозным» изменениям. Это основной источник техдолга в монолитах.</warning>
        </chapter>

        <chapter title="Основные подходы к проектированию монолита">
            <chapter title="Слоистая архитектура (Layered)">
                <p>Классическая стратификация: <code>Presentation</code> → <code>Application</code> → <code>Domain</code> → <code>Infrastructure</code>. Слои формируют «вертикальные правила зависимости»: верхние зависят от нижних, но не наоборот.</p>
                <tip>Фиксируйте зависимость «вверх-вниз» линтерами и правилом импорта: слой не может импортировать код из слоя над собой.</tip>
                <warning>Частая ошибка — бизнес-правила в инфраструктуре (валидация, агрегаты в ORM-энтитях). Это размывает модель.</warning>
            </chapter>

            <chapter title="Модульный монолит (Modular Monolith)">
                <p>Монолит разделён на изолированные <tooltip term="Модуль">модули</tooltip> с публичными <tooltip term="Контракт">контрактами</tooltip>. Внутренности модулей закрыты, межмодульная коммуникация идёт через фасады, команды/запросы или доменные события (в памяти).</p>
                <note>Модульный монолит — отличная ступень перед микросервисами: границы и контракты уже есть, останется вынести процессы в отдельные сервисы.</note>
            </chapter>

            <chapter title="Вертикальные срезы (Feature Slices)">
                <p>Структурирование по фичам/поддоменам: каждая фича содержит свой <code>ui</code>, <code>application</code>, <code>domain</code>, <code>infrastructure</code>. Минимизируется кросс-зависимость между фичами, команды работают автономно.</p>
                <tip>Хорошо сочетается с <tooltip term="Ограниченный контекст (Bounded Context)">ограниченными контекстами</tooltip> из DDD.</tip>
            </chapter>

            <chapter title="Чистая архитектура / Гексагональная архитектура">
                <p>Домен в центре, вокруг — порты/адаптеры. Инфраструктура подключается «снаружи» и подменяема. Это усиливает тестируемость и независимость домена.</p>
            </chapter>

        </chapter>

        <chapter title="Ключевые архитектурные решения в монолите">
            <list>
                <li><format style="bold">Границы модулей.</format> Определяйте инварианты и агрегаты. Что должно меняться транзакционно вместе — в одном модуле.</li>
                <li><format style="bold">Политика транзакций.</format> Явно описывайте границы <tooltip term="Согласованность">ACID-согласованности</tooltip>. Сквозные транзакции через всё приложение — антипаттерн.</li>
                <li><format style="bold">Доступ к данным.</format> Избегайте «общей» БД как интеграционного слоя: модуль не должен читать таблицы другого модуля напрямую.</li>
                <li><format style="bold">Коммуникация модулей.</format> Команды/запросы и внутрипроцессные события лучше прямых импортов. Это снижает сцепление.</li>
                <li><format style="bold">Наблюдаемость.</format> Трейсы на уровень модулей/юзкейсов, метрики по горячим путям, структурированные логи.</li>
                <li><format style="bold">Эволюция.</format> План миграций схемы, фича-флаги, «двойная запись» при рефакторинге.</li>
            </list>
        </chapter>

        <chapter title="Использование КОП для разбиения разработки на команды">
            <p><format style="bold">КОП (Компонентно-ориентированное программирование)</format> — дисциплина проектирования, где система строится из независимых <tooltip term="Компонент">компонентов</tooltip> с чёткими интерфейсами и контрактами. В монолите это обеспечивает командную автономию без разделения на микросервисы.</p>
            <list>
                <li><format style="bold">Компонент &rarr; команда.</format> Каждому компоненту назначается <tooltip term="Компонентная команда">компонентная команда</tooltip> (ownership кода, сборки, инцидентов).</li>
                <li><format style="bold">Контракты вместо общих утилит.</format> Публичная поверхность компонента — фасады/порты; общий «утилитарный» слой — только для кросс-срезов (логирование, авторизация).</li>
                <li><format style="bold">Изоляция хранилища.</format> Таблицы компонента отделены (схема/префикс). Доступ — только через порт компонента.</li>
                <li><format style="bold">Внутренние события.</format> Компоненты публикуют доменные события (в памяти) и подписываются на них — без прямых импортов реализаций.</li>
                <li><format style="bold">Границы изменения.</format> Изменение инварианта одного компонента не должно требовать каскада в остальных.</li>
            </list>


            <code-block lang="typescript">

export type ChargeResult = { ok: boolean; txId?: string };

export interface PaymentsPort {
    charge(orderId: string, amount: number): Promise&lt;ChargeResult&gt;;
}

export class OrdersService {
    constructor(private readonly payments: PaymentsPort) {
    }

    async place(orderId: string, amount: number) {
        const res = await this.payments.charge(orderId, amount);
        console.log(res.ok); // true
        return res;
    }
}</code-block>

            
            <note>КОП уменьшает площадь конфликта при мерджах: команды редко правят чужой код, т.к. взаимодействуют через стабильные контракты.</note>
            <warning>Антипаттерн: «общий домен» — когда один «бог-слой» видит все таблицы/модели. Это разрушает автономию и повышает связность.</warning>
            

        </chapter>

        <chapter title="Практики для монолита в продакшне">
            <list>
                <li><format style="bold">Статические правила импорта.</format> Линт-правила/арх-линтеры запрещают пересечение модульных границ.</li>
                <li><format style="bold">Контрактные тесты.</format> Тесты проверяют публичные фасады модулей и события, а не приватные детали.</li>
                <li><format style="bold">Миграции с обратной совместимостью.</format> Схема меняется в несколько шагов: расширение → двойная запись → переключение → очистка.</li>
                <li><format style="bold">Версионирование контрактов.</format> Переход через <code>v1</code>/<code>v2</code> фасадов, период совместимости.</li>
                <li><format style="bold">Стратегии развертывания.</format> Blue/Green, Canary, быстрый откат. Единый артефакт упрощает управление риском.</li>
            </list>
        </chapter>

        <chapter title="Типичные анти-паттерны и как их избегать">
            <list>
                <li><format style="bold">Big Ball of Mud.</format> Лечится модульными границами, контрактами и архитектурным линкующим контролем.</li>
                <li><format style="bold">Общая БД как интеграционный слой.</format> Вместо прямого чтения чужих таблиц — порт/события.</li>
                <li><format style="bold">God Object / God Service.</format> Делите по инвариантам и агрегатам, а не по слоям контроллер/сервис/репозиторий механически.</li>
                <li><format style="bold">Сквозные транзакции.</format> Явно обозначайте границы. Межмодульные операции — через «сага»-подобные процессы внутри одного процесса.</li>
            </list>
            <warning>Если модуль А импортирует приватные типы модуля Б — вы потеряли независимость релизов и тестируемость. Срочно переведите зависимость на публичный порт.</warning>
        </chapter>

        <chapter title="Масштабирование и эволюция монолита">
            <list>
                <li><format style="bold">Scale-up &amp; горизонтальное масштабирование процесса.</format> Реплики приложения за балансировщиком, sticky-sessions при необходимости.</li>
                <li><format style="bold">Разделение нагрузки.</format> Вынесение фоновых работ в очереди/воркеры, read-replicas для отчётности.</li>
                <li><format style="bold">Стратегия «Strangler Fig».</format> Когда появится потребность — выносите самый горячий компонент в отдельный сервис, не ломая контракты.</li>
            </list>
            <tip>Первые месяцы/релизы почти всегда выгоднее делать как <tooltip term="Модульный монолит">модульный монолит</tooltip>. Микросервисы — инструмент оптимизации под конкретные бутылочные горлышки.</tip>
        </chapter>

        <chapter title="Мини-шаблоны структуры репозитория (пример)">
    <code-block lang="bash">.
├─ app/
│  ├─ modules/
│  │  ├─ orders/
│  │  │  ├─ application/
│  │  │  ├─ domain/
│  │  │  └─ infrastructure/
│  │  └─ payments/
│  │     ├─ application/
│  │     ├─ domain/
│  │     └─ infrastructure/
│  ├─ shared/        # только кросс-срез: логирование, auth, tracing
│  └─ platform/      # запуск, конфиг, DI-контейнер
└─ tests/</code-block>
            <note>«shared» не должен хранить бизнес-логику. Это частая причина «утечки» зависимостей.</note>
        </chapter>

        <chapter title="Пример инварианта на уровне БД">
            <p>Даже в монолите <tooltip term="Инвариант">инварианты</tooltip> лучше дублировать: в домене и в БД.</p>
            <code-block lang="sql">ALTER TABLE orders
                ADD CONSTRAINT chk_total_non_negative
                    CHECK (total_amount &gt;= 0);</code-block>
        </chapter>

        <chapter title="Чек-лист готовности">
            <list>
                <li>Определены публичные фасады модулей; приватное не импортируется снаружи.</li>
                <li>Покрыты контрактные тесты и тесты инвариантов.</li>
                <li>Наблюдаемость: метрики по модулю и ключевым юзкейсам, трассировка.</li>
                <li>Схема БД разделена по модулям (схемы/префиксы), миграции обратносуместимы.</li>
                <li>Релизная стратегия документирована, откат проверен.</li>
            </list>
        </chapter>
</topic>