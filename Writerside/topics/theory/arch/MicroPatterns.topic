<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Паттерны микросервисной архитектуры" id="MicroPatterns">

    <chapter title="Зачем нужны паттерны">
        <p>Микросервисная архитектура разбивает систему на набор изолированных
            <tooltip term="Сервис">сервисов</tooltip>
            , каждый из которых владеет своей областью данных и логикой. Паттерны — это проверенные способы решать
            типичные проблемы распределённых систем: координация бизнес-процессов, обмен сообщениями, устойчивость к
            сбоям, согласованность данных, эволюция API и др.
        </p>
        <tip>
            <p>Думайте о паттернах как о словаре решений: одно и то же требование (например, «оформить заказ») можно
                реализовать через
                <tooltip term="Оркестрация">оркестрацию</tooltip>
                или
                <tooltip term="Хореография">хореографию</tooltip>
                — выбор зависит от связности, наблюдаемости, зрелости команды и динамики домена.
            </p>
        </tip>
        <warning><p>Паттерн — не самоцель. Он добавляет сложность. Применяйте только там, где выгода (масштабируемость,
            независимые релизы, устойчивость) перекрывает издержки (координация, отладка, кросс-сервисная
            транзакционность).</p></warning>
    </chapter>

    <chapter title="Базовые шаблонные сервисы и слои">
        <chapter title="Edge-слой: API Gateway и BFF">
            <p>
                <format style="bold">API Gateway</format>
                — фасад, единая точка входа для внешних клиентов. Выполняет агрегацию, маршрутизацию, политику
                безопасности, ограничение трафика, кэширование.
                <format style="bold">BFF</format>
                (Backend For Frontend) — специализированный фасад под конкретный клиент (веб, мобильный), скрывающий
                сложность внутренних API.
            </p>
            <note><p>Разносите общие кросс-срезовые задачи (аутентификация, лимиты, логирование) в Gateway, а
                форматирование ответов под конкретный UI — в BFF. Так вы уменьшите дублирование логики в фронтендах.</p>
            </note>
            <warning><p>Не превращайте Gateway в «толстый» монолит: бизнес-правила и длинные блокирующие сценарии должны
                жить в доменных сервисах.</p></warning>
        </chapter>


        <chapter title="Доменные сервисы (Core Services)">
            <p>Каждый доменный сервис владеет своей
                <tooltip term="Модель_данных">моделью данных</tooltip>
                и реализует чёткий
                <tooltip term="Bounded_Context">bounded context</tooltip>
                . Общение между сервисами — асинхронными событиями или синхронными запросами, в зависимости от
                критичности и зависимостей.
            </p>
            <tip><p>Стройте сервисы вокруг устойчивых доменных инвариантов (например, <code>Payment</code>,
                <code>Order</code>, <code>Inventory</code>), а не вокруг технических слоёв (например, «сервис БД»).</p>
            </tip>
        </chapter>

        <chapter title="Сервисы-поддержки (Supporting Services)">
            <list>
                <li>
                    <format style="bold">Auth/Identity</format>
                    — аутентификация, авторизация, управление токенами.
                </li>
                <li>
                    <format style="bold">Notification</format>
                    — e-mail/SMS/Push, шаблоны, ретраи, дед-леттер.
                </li>
                <li>
                    <format style="bold">Reporting/Analytics</format>
                    — витрины, материализованные представления.
                </li>
                <li>
                    <format style="bold">File/Media</format>
                    — загрузка, хранение, CDN-ссылки, вирус-скан.
                </li>
            </list>
            <note><p>Вынесение кросс-доменных задач в отдельные сервисы снижает дублирование и упрощает масштабирование
                по профилю нагрузки.</p></note>
        </chapter>


    </chapter>

    <chapter title="Паттерны интеграции сервисов">
        <chapter title="Синхронные запросы/ответы (HTTP/gRPC)">
            <p>Используются для запросов, требующих мгновенной обратной связи (например, проверка баланса перед
                оплатой). Подход прост в реализации, но увеличивает связность и риск каскадных таймаутов.</p>
            <warning>
                <p>В цепочке из N синхронных вызовов вероятность таймаута растёт. Всегда применяйте
                    <tooltip term="Circuit_Breaker">Circuit Breaker</tooltip>
                    , таймауты, лимиты повторов и
                    <tooltip term="Bulkhead">Bulkhead</tooltip>
                    .
                </p>
            </warning>
            <code-block lang="typescript">
// Gateway -&gt; Orders -&gt; Payments (глубина 2, таймауты короче суммарного SLA)
const paymentOk = await withTimeout(() =&gt; payments.authorize(orderId), 800);
      </code-block>
        </chapter>


        <chapter title="Асинхронные события (Event-Driven)">
            <p>Сервисы публикуют факты (
                <format style="bold">события-доменные факты</format>
                ) в шину; подписчики реагируют независимо, что снижает связность и повышает масштабируемость.
            </p>
            <tip><p>Событие — прошедший факт, а не команда. Именуйте прошедшим временем: <code>OrderCreated</code>,
                <code>PaymentAuthorized</code>.</p></tip>
        </chapter>


        <chapter title="Команды (Command) и запросы (Query)">
            <p>
                <format style="bold">Команда</format>
                инициирует действие и может быть асинхронной.
                <format style="bold">Запрос</format>
                читает состояние и обычно синхронен. Разделение упрощает масштабирование и кэширование.
            </p>
            <note>
                <p>Вместе формируют основу
                    <tooltip term="CQRS">CQRS</tooltip>
                    : отдельные модели для чтения и записи.
                </p>
            </note>
        </chapter>


    </chapter>

    <chapter title="Оркестрация и Хореография: сравнение и применение">
        <chapter title="Что такое Оркестрация">
            <p>
                <tooltip term="Оркестрация">Оркестрация</tooltip>
                — централизованное управление долгоживущим бизнес-процессом специальным координатором
                (оркестратором/процесс-менеджером). Он вызывает шаги по сценарию, хранит состояние, выполняет
                компенсации.
            </p>
            <list>
                <li>
                    <format style="bold">Плюсы</format>
                    : прозрачный контроль потока, явные состояния, простая отладка, единые SLA.
                </li>
                <li>
                    <format style="bold">Минусы</format>
                    : центральная точка координации, потенциальная «бутылочная горлышко», сильнее связь с участниками.
                </li>
            </list>
            <tip><p>Оркестратор — отдельный компонент/сервис. Он не обязан быть «бог-объектом» — держите только
                состояние процесса и ссылки на шаги.</p></tip>
        </chapter>


        <chapter title="Что такое Хореография">
            <p>
                <tooltip term="Хореография">Хореография</tooltip>
                — распределённая координация: каждый участник подписывается на релевантные события и самостоятельно
                решает, что делать дальше. Нет единого центра принятия решений.
            </p>
            <list>
                <li>
                    <format style="bold">Плюсы</format>
                    : низкая связность, простая эволюция, горизонтальная масштабируемость.
                </li>
                <li>
                    <format style="bold">Минусы</format>
                    : сложнее прослеживать цепочку, риск непреднамеренных циклов, труднее ввести глобальные правила.
                </li>
            </list>
            <warning><p>При добавлении нового подписчика меняется поведение системы. Вводите контрактные тесты и
                наблюдаемость с кореляцией трассировок.</p></warning>
        </chapter>


        <chapter title="Где какой подход уместен">
            <list>
                <li>
                    <format style="bold">Оркестрация</format>
                    : сложные, регламентированные процессы с явными этапами и компенсациями (оформление кредита, KYC,
                    биллинг). Требуется единая точка контроля статусов.
                </li>
                <li>
                    <format style="bold">Хореография</format>
                    : событийное расширение вокруг «ядра» (уведомления, аналитика, кэш-проекции, интеграции с
                    партнёрами), где важно низкое сцепление и независимые релизы.
                </li>
            </list>
            <note><p>Комбинируйте: критический «скелет» процесса — оркестрация; периферийные реакции — хореография.</p>
            </note>
        </chapter>


    </chapter>

    <chapter title="Транзакции, саги и согласованность">
        <chapter title="Сага как общий паттерн">
            <p>
                <tooltip term="Сага">Сага</tooltip>
                — разбиение распределённой транзакции на последовательность локальных шагов с
                <format style="bold">компенсирующими действиями</format>
                . Бывает оркестрируемая и хореографическая.
            </p>
            <code-block lang="typescript">
// Оркестрируемая сага (псевдокод)
await step("ReserveInventory", () =&gt; inventory.reserve(orderId), () =&gt; inventory.release(orderId));
await step("AuthorizePayment", () =&gt; payments.authorize(orderId), () =&gt; payments.refund(orderId));
await step("ConfirmOrder", () =&gt; orders.confirm(orderId), () =&gt; orders.markFailed(orderId));
      </code-block>
            <warning><p>Компенсация — не всегда «идеальный откат». Продумывайте неизбежные остаточные эффекты
                (уведомления, сторонние системы).</p></warning>
        </chapter>


        <chapter title="Outbox и транзакционная доставка">
            <p>
                <tooltip term="Outbox">Outbox</tooltip>
                — запись события в таблицу <code>outbox</code> в одной транзакции с изменением агрегата, а затем
                асинхронная публикация из outbox в брокер. Гарантирует «сначала запись, потом публикация» без потерь.
            </p>
            <code-block lang="sql">


\-- Изменение статуса заказа и запись события в одной транзакции
BEGIN;
UPDATE orders
SET status = 'CONFIRMED'
WHERE id = 'o-42';
INSERT INTO outbox(id, topic, payload, created\_at)
VALUES ('e-123', 'order.confirmed', '{...}', now());
COMMIT; </code-block>
            <tip><p>Добавьте <code>processed\_at</code>, <code>retry\_count</code>, идемпотентные ключи и дед-леттер
                очередь для «ядовитых» сообщений.</p></tip>
        </chapter>


        <chapter title="CQRS и Event Sourcing">
            <p>
                <tooltip term="CQRS">CQRS</tooltip>
                разделяет модели записи и чтения для масштабирования и целостности.
                <tooltip term="Event_Sourcing">Event Sourcing</tooltip>
                хранит последовательность событий как источник истины; состояние восстанавливается через «реплей».
            </p>
            <warning><p>Event Sourcing повышает сложность (миграции, реплей, эволюция схемы событий). Используйте при
                высокой ценности аудита и воспроизводимости.</p></warning>
        </chapter>


    </chapter>

    <chapter title="Надёжность и устойчивость">
        <list>
            <li>
                <tooltip term="Circuit_Breaker">Circuit Breaker</tooltip>
                : «размыкает цепь» при ошибках/таймаутах, затем полуоткрытый режим для проб.
            </li>
            <li>
                <tooltip term="Bulkhead">Bulkhead</tooltip>
                : изоляция пулов (соединения, очереди) между фичами, чтобы сбой не уронил всё.
            </li>
            <li>
                Повторы
                с экспоненциальной паузой и джиттером; уважайте идемпотентность.
            </li>
            <li>
                <tooltip term="Idempotency">Идемпотентность</tooltip>
                : повтор одного и того же запроса не меняет итоговое состояние.
            </li>
            <li>
                Таймауты
                и дедлайны для шагов саги;
                компенсации
                и алерты.
            </li>
            <li>
                <tooltip term="DLQ">Dead-Letter Queue</tooltip>
                для сообщений, не прошедших после N попыток.
            </li>
        </list>
        <code-block lang="typescript">
// Идемпотентный обработчик сообщения
const key = msg.headers["Idempotency-Key"];
if (await store.seen(key)) return; // уже обработано
await handle(msg.payload);
await store.mark(key);
    </code-block>
        <warning><p>Повторы без идемпотентности приводят к двойному списанию, дублированию заказов и «фантомным»
            состояниям.</p></warning>
    </chapter>

    <chapter title="Версионирование и эволюция контрактов">
        <p>Контракты должны эволюционировать без «ломающих» изменений: добавляйте поля необязательными, не
            переименовывайте значения событий, используйте
            <format style="bold">согласованную схему</format>
            (Avro/JSON Schema/Protobuf) и контрактные тесты потребителей.
        </p>
        <tip><p>Для HTTP — поддерживайте параллельно <code>/v1</code> и <code>/v2</code>. Для событий — вводите новые
            типы (<code>OrderConfirmed.v2</code>), сохраняя старые до миграции подписчиков.</p></tip>
    </chapter>

    <chapter title="Наблюдаемость (Observability)">
        <p>Три столпа: логирование, метрики, трассировка. Для распределённых процессов обязательно
            <format style="bold">корреляция</format>
            через <code>traceId</code>/<code>spanId</code>, проброс контекста через шину, спаны на шаги саги и
            компенсации.
        </p>
        <warning><p>Без трассировки хореография превращается в «чёрный ящик»: сложно понять, где «застряла» цепочка.</p>
        </warning>
    </chapter>

    <chapter title="Выбор брокера и модель доставки">
        <p>Оценивайте семантику доставки (
            <format style="bold">at-least-once</format>
            ,
            <format style="bold">at-most-once</format>
            ,
            <format style="bold">exactly-once</format>
            как архитектурная цель), требования к порядку, объёмы сообщений, задержки и количество подписчиков.
        </p>
        <note>
            <p>В большинстве бизнес-кейсов достаточно
                <format style="bold">at-least-once</format>
                + идемпотентность потребителей и
                <tooltip term="Outbox">outbox</tooltip>
                у продюсеров.
            </p>
        </note>
    </chapter>

    <chapter title="Примеры применения паттернов по случаям">
        <chapter title="Оформление заказа (ядро + периферия)">
            <list>
                <li>
                    <format style="bold">Оркестрация</format>
                    для ядра: резерв склада → авторизация платежа → подтверждение заказа → счёт. Явные компенсации при
                    отказе.
                </li>
                <li>
                    <format style="bold">Хореография</format>
                    для периферии: уведомления, обновление рекомендаций, аналитические проекции, вебхуки партнёрам.
                </li>
            </list>
        </chapter>
        <chapter title="Пополнение баланса (внешние интеграции)">
            <p>Асинхронные вебхуки от провайдера → хореография реакций (обновить баланс, отправить чек). Оркестратор не
                нужен, если нет сложных зависимостей.</p>
        </chapter>
        <chapter title="Возврат средств (компенсационные сценарии)">
            <p>Оркестрация с явным хранением статусов: <code>REQUESTED</code> → <code>APPROVED</code> →
                <code>REFUNDED</code>. Компенсации и SLA на каждом шаге, DLQ для ошибок провайдера.</p>
        </chapter>
    </chapter>

    <chapter title="Чек-лист внедрения">
        <list>
            <li>Определите границы контекстов и агрегатов. Сервис владеет своей схемой БД.</li>
            <li>Выберите модель координации: оркестрация (ядро) vs хореография (расширения).</li>
            <li>Гарантируйте доставку: outbox, идемпотентность, ретраи, DLQ.</li>
            <li>Добавьте устойчивость: circuit breaker, timeouts, bulkhead, backoff с джиттером.</li>
            <li>Обеспечьте наблюдаемость: трассировка сквозь все шаги, корреляция по traceId.</li>
            <li>Планируйте эволюцию контрактов: совместимость, версии, контрактные тесты.</li>
        </list>
    </chapter>

</topic>