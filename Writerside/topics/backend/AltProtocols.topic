<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Альтернативные протоколы" id="AltProtocols">

    <chapter title="Зачем нужны альтернативные протоколы">
        <p>Классический HTTP/1.1 request-response отлично подходит для простых синхронных операций: клиент сделал запрос
            — сервер вернул ответ. Но в реальных системах все чаще требуются двунаправленные каналы, потоковая доставка
            данных, строгие контракты, эффективная бинарная сериализация и прямые соединения между клиентами. Здесь в
            игру вступают
            <tooltip term="Альтернативные протоколы">альтернативные протоколы</tooltip>
            :
            <tooltip term="WebSocket">WebSocket</tooltip>
            , семейство
            <tooltip term="RPC">RPC</tooltip>
            (включая
            <tooltip term="JSON-RPC">JSON-RPC</tooltip>
            и
            <tooltip term="gRPC">gRPC</tooltip>
            ),
            <tooltip term="GraphQL">GraphQL</tooltip>
            и
            <tooltip term="WebRTC">WebRTC</tooltip>
            . Каждый решает свою подзадачу: realtime, строгий контракт, оптимизация трафика, p2p и мультимедийные
            стримы.
        </p>
        <list>
            <li>
                <format style="bold">Двунаправленность и события:</format>
                push-уведомления, чаты, биржевые котировки, телеметрия.
            </li>
            <li>
                <format style="bold">Строгие контракты и схемы:</format>
                описание типов и автоматическая генерация кода.
            </li>
            <li>
                <format style="bold">Производительность:</format>
                бинарные форматы (
                <tooltip term="Protocol Buffers">Protocol Buffers</tooltip>
                ) и потоковые RPC сокращают задержки и трафик.
            </li>
            <li>
                <format style="bold">P2P и мультимедиа:</format>
                прямые соединения для видео/аудио/данных без центрального проксирования.
            </li>
        </list>
        <warning>Ошибка выбора протокола «на слух». Без анализа домена легко выбрать модный, но неподходящий инструмент.
            Сначала формализуйте требования: типы трафика (события, запрос-ответ, потоки), SLIs (latency, throughput),
            ограничения сети и безопасности.
        </warning>
    </chapter>
    <chapter title="WebSocket (WS)">
        <p>
            <tooltip term="WebSocket">WebSocket</tooltip>
            — это постоянное TCP-соединение между клиентом и сервером поверх HTTP/1.1 upgrade или HTTP/2 (H2 WebSocket),
            позволяющее обеим сторонам отправлять сообщения в любой момент времени. Хорошо подходит для realtime UI
            (чаты, игры, панели мониторинга) и широковещательных событий.
        </p>
        <note>WS решает задачу серверного push без долгого опроса. Он особенно полезен там, где количество событий
            велико, а задержка критична.
        </note>
        <chapter title="Как выглядит рукопожатие (handshake)">
            <code-block
                    lang="http">
GET /realtime HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Version: 13
Origin: https://app.example.com
            </code-block>
            <code-block
                    lang="http">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
            </code-block>
        </chapter>
        <chapter title="Пример текстового сообщения по WS">
            <code-block lang="json">
                {
                    "type": "price_update",
                    "symbol": "AAPL",
                    "price": 232.15,
                    "ts": 1727606400000
                } </code-block>
        </chapter>
        <tip>Используйте компрессию сообщений (permessage-deflate) осторожно: это экономит трафик, но увеличивает
            нагрузку на CPU.
        </tip>
        <warning>Безопасность: защищайте соединение WSS и проверяйте токен аутентификации при установке и периодически
            (re-auth), иначе возможен угон сессии. Учитывайте, что CORS не применяется к WS так же, как к HTTP — нужен
            собственный контроль origin/токена.
        </warning>
    </chapter>
    <chapter title="Polling (опрос)">
        <p>
            Polling
            — это периодический опрос сервера по протоколу
            <tooltip term="HTTP">HTTP</tooltip>
            с целью узнать, появились ли новые данные или события. Клиент по таймеру отправляет запрос, сервер отвечает
            текущим состоянием. Такой подход прост и работает «везде», но может быть неэффективным при высокой частоте
            запросов или редких обновлениях.
        </p>
        <chapter title="Короткий (регулярный) polling"><p>Клиент с фиксированным интервалом (например, каждые 5–10
            секунд) отправляет одинаковый запрос. Подходит для медленно меняющихся данных или в условиях, когда нельзя
            держать постоянное соединение.</p>
            <code-block lang="http">
GET /api/notifications?limit=20 HTTP/1.1
Host: example.com
Accept: application/json
            </code-block>
            <code-block lang="json">
                {
                    "items": [
                        {
                            "id": "n-1201",
                            "type": "message",
                            "ts": 1727606400000
                        }
                    ],
                    "hasMore": false
                } </code-block>
            <note>Увеличивайте интервал опроса, если изменений нет (backoff), и уменьшайте при появлении активности —
                это снижает нагрузку и трафик.
            </note>
        </chapter>
        <chapter title="Длинный polling (long polling)"><p>Клиент отправляет запрос и держит соединение открытым, пока
            сервер не пошлет ответ (или не истечет таймаут). Если изменений нет, сервер отвечает ближе к таймауту, после
            чего клиент немедленно повторяет запрос. Таким образом достигается почти «реалтайм» без постоянного
            двунаправленного канала.</p>
            <code-block lang="http">
                GET /api/events/stream?cursor=eyJvZmZzZXQiOjEyMzR9 HTTP/1.1
                Host: example.com
                Accept: application/json
                Cache-Control: no-cache
            </code-block>
            <code-block lang="json">
                {
                    "events": [
                        {
                            "type": "price_update",
                            "symbol": "AAPL",
                            "price": 232.15,
                            "ts": 1727606401000
                        }
                    ],
                    "nextCursor": "eyJvZmZzZXQiOjEyMzV9"
                } </code-block>
            <tip>Держите серверный таймаут 25–55 секунд (в зависимости от инфраструктуры) и возвращайте пустой ответ по
                таймауту, чтобы клиент сразу переоткрыл запрос.
            </tip>
        </chapter>
        <chapter title="Оптимизации и заголовки кэширования"><p>Даже при polling можно резко сократить трафик с помощью
            условных запросов и кэша.</p>
            <code-block
                    lang="http">
                GET /api/feed HTTP/1.1
                Host: example.com
                Accept: application/json
                If-None-Match: "feed-v3-9f1c"
                If-Modified-Since: Tue, 30 Sep 2025 00:00:00 GMT
            </code-block>
            <code-block
                    lang="http">
                HTTP/1.1 304 Not Modified
        ETag: "feed-v3-9f1c"
        Cache-Control: no-cache
            </code-block>
            <note>Используйте
                <tooltip term="ETag">ETag</tooltip>
                и
                Last-Modified
                : при отсутствии изменений сервер вернет 304, экономя трафик и CPU.
            </note>
        </chapter>
        <chapter title="Когда выбирать polling, а когда нет">
            <list>
                <li>
                    <format style="bold">Выберите polling</format>
                    , если данные меняются редко, а инфраструктура не позволяет держать постоянные соединения (например,
                    ограниченные прокси/балансировщики).
                </li>
                <li>
                    <format style="bold">Рассмотрите long polling</format>
                    , если нужен почти «реалтайм», но WebSocket/HTTP/2 недоступны.
                </li>
                <li>
                    <format style="bold">Предпочтительнее WS/SSE</format>
                    , если требуется частая доставка событий с минимальной задержкой и двунаправленность (
                    <tooltip term="WebSocket">WS</tooltip>
                    ) или односторонний поток сервер→клиент (SSE).
                </li>
            </list>
        </chapter>

        <warning>Нагрузочные риски: частый polling от тысяч клиентов создает «пилообразную» нагрузку (thundering herd),
            лишний трафик и расходы. Смягчайте экспоненциальным backoff, джиттером (рандомизация интервалов), условными
            запросами и ограничением частоты.
        </warning>
        <tip>Стандартизируйте контракт: передавайте <code>cursor</code>/<code>since</code> для инкрементального чтения,
            TTL для кэша и четко документируйте серверные таймауты long polling.
        </tip>
    </chapter>
    <chapter title="RPC-системы: общий взгляд">
        <p>
            <tooltip term="RPC">RPC</tooltip>
            (Remote Procedure Call) моделирует удаленный вызов функции как локальный: клиент вызывает метод с
            аргументами, сервер возвращает результат (или поток результатов). Ключевые элементы:
            <tooltip term="IDL">IDL</tooltip>
            /
            схема
            для описания типов, транспорт (HTTP/2, HTTP/3, TCP), и формат сериализации (JSON, Protobuf, Avro).
        </p>
        <list>
            <li>
                <format style="bold">Unary:</format>
                один запрос — один ответ.
            </li>
            <li>
                <format style="bold">Server streaming:</format>
                один запрос — поток ответов.
            </li>
            <li>
                <format style="bold">Client streaming:</format>
                поток запросов — один ответ.
            </li>
            <li>
                <format style="bold">Bidirectional streaming:</format>
                двунаправленный поток.
            </li>
        </list>
        <note>RPC удобен для сервис-сервис общения в микросервисах, где важны строгие контракты и эволюция API.</note>
    </chapter>
    <chapter title="JSON-RPC">
        <p>
            <tooltip term="JSON-RPC">JSON-RPC 2.0</tooltip>
            — легкий текстовый RPC-протокол без строгой схемы типов: сообщения — это JSON-объекты с полями jsonrpc,
            method, params и id. Работает поверх HTTP(S), WS или другого транспорта.
        </p>
        <chapter title="Пример запрос-ответ">
            <code-block lang="json">
                {
                    "jsonrpc": "2.0",
                    "method": "subtract",
                    "params": [
                        42,
                        23
                    ],
                    "id": 1
                } </code-block>
            <code-block lang="json">
                {
                    "jsonrpc": "2.0",
                    "result": 19,
                    "id": 1
                } </code-block>
        </chapter>
        <chapter title="Пример ошибки">
            <code-block lang="json">
                {
                    "jsonrpc": "2.0",
                    "error": {
                        "code": -32601,
                        "message": "Method not found"
                    },
                    "id": 1
                } </code-block>
        </chapter>
        <chapter title="Пакетные вызовы (batch)">
            <code-block lang="json">
                [
                    {
                        "jsonrpc": "2.0",
                        "method": "sum",
                        "params": [
                            1,
                            2,
                            3
                        ],
                        "id": 2
                    },
                    {
                        "jsonrpc": "2.0",
                        "method": "notify_hello",
                        "params": [
                            7
                        ]
                    },
                    {
                        "jsonrpc": "2.0",
                        "method": "subtract",
                        "params": [
                            42,
                            23
                        ],
                        "id": 3
                    }
                ] </code-block>
        </chapter>
        <warning>Отсутствие строгой схемы усложняет эволюцию API: клиенты могут отправлять неожиданные типы. Добавляйте
            собственные схемы валидации (JSON Schema) и версионирование методов.
        </warning>
    </chapter>
    <chapter title="gRPC">
        <p>
            <tooltip term="gRPC">gRPC</tooltip>
            — фреймворк RPC поверх HTTP/2 с бинарной сериализацией
            <tooltip term="Protocol Buffers">Protocol Buffers</tooltip>
            (protobuf). Обеспечивает строгие контракты через .proto-файлы, генерацию клиент/сервер кода, 4 режима
            вызовов (unary/streams) и эффективную передачу данных.
        </p>
        <chapter title="Пример .proto контракта"> <code-block lang="protobuf">
syntax = "proto3";

package orders.v1;

// Сущность и DTO
message OrderRequest {
    string id = 1;
}

message Order {
    string id = 1;
    string status = 2;
}

// Сервис и методы
service OrderService {
    rpc GetOrder (OrderRequest) returns (Order);
    rpc StreamOrders (OrderRequest) returns (stream Order);
    rpc UploadChunks (stream Chunk) returns (UploadResult);
    rpc Chat (stream Message) returns (stream Message);
}

message Chunk { bytes data = 1; }
message UploadResult { string fileId = 1; }
message Message { string text = 1; int64 ts = 2; }
</code-block>
        </chapter>
        <note>HTTP/2 мультиплексирует несколько RPC по одному соединению, уменьшает накладные расходы заголовков и
            поддерживает потоки.
        </note>
        <warning>Совместимость схем: поля в protobuf нужно эволюционировать аккуратно — не переиспользуйте номера полей,
            удаленные поля помечайте reserved. Неправильная эволюция ломает межверсную совместимость клиентов.
        </warning>
    </chapter>

    <chapter title="GraphQL">
        <p>
            <tooltip term="GraphQL">GraphQL</tooltip>
            — язык запросов к API и схема типов. Клиент формирует точный запрос к графу данных (query) и получает ровно
            необходимые поля. Также поддерживаются
            mutation и subscription (обычно поверх WS).
        </p>
        <chapter title="Пример схемы (SDL)"> <code-block lang="text"> type Order { id: ID! status: String! total: Float! items: [OrderItem!]! }

type OrderItem {
    sku: String!
    qty: Int!
    price: Float!
}

type Query {
    order(id: ID!): Order
    orders(limit: Int = 10): [Order!]!
}

type Mutation {
    updateOrderStatus(id: ID!, status: String!): Order!
}

type Subscription {
    orderUpdated(id: ID!): Order!
}
</code-block>
        </chapter>
        <chapter title="Пример запроса и ответа">
<code-block lang="text">
query GetOrder($id: ID!) {
    order(id: $id) {
        id
        status
        total
        items { sku qty }
    }
}
</code-block>
            <code-block lang="json">
{
    "data": {
        "order": {
            "id": "o-1001",
            "status": "SHIPPED",
            "total": 149.90,
            "items": [
                {
                    "sku": "A-1",
                    "qty": 2
                }
            ]
        }
    }
}
</code-block>
        </chapter>
        <warning>N+1 проблема: при наивной реализации резолверов сервер может ходить в БД по одному запросу на каждый
            объект. Используйте батчеры/дата-лоадеры и кэширование.
        </warning>
        <note>Схема — контракт: документируйте директивы, nullable/required поля и версии. Стабильная схема снижает риск
            поломок на фронте.
        </note>
    </chapter>

    <chapter title="WebRTC (p2p)">
        <p>
            <tooltip term="WebRTC">WebRTC</tooltip>
            — стек для установления peer-to-peer соединений между браузерами и нативными приложениями. Поддерживает
            передачу аудио/видео и данных (
            <tooltip term="DataChannel">DataChannel</tooltip>
            ) с минимальными задержками. Для сигналинга используется сторонний канал (обычно HTTP/WS), обмен
            <tooltip term="SDP">SDP</tooltip>
            и
            <tooltip term="ICE">ICE</tooltip>
            -кандидатами; для обхода NAT —
            <tooltip term="STUN">STUN</tooltip>
            /
            <tooltip term="TURN">TURN</tooltip>
            .
        </p>
        <chapter title="Фрагмент SDP offer">
            <code-block lang="Plain Text">
                v=0
                o=- 46117327 2 IN IP4 127.0.0.1
                s=-
                t=0 0
                a=group:BUNDLE 0 1
                m=audio 9 UDP/TLS/RTP/SAVPF 111
                a=rtpmap:111 opus/48000/2
                m=application 9 DTLS/SCTP 5000
                a=sctp-port:5000
            </code-block>
        </chapter>
        <chapter title="ICE-кандидат (как обычно передают по сигналингу)">
            <code-block lang="json">
                {
                    "candidate": "candidate:1 1 UDP 2122260223 192.0.2.10 53405 typ host",
                    "sdpMid": "0",
                    "sdpMLineIndex": 0
                } </code-block>
        </chapter>
        <chapter title="Сообщение по DataChannel">
            <code-block lang="json">
                {
                    "type": "cursor",
                    "x": 512,
                    "y": 284,
                    "ts": 1727606400123
                } </code-block>
        </chapter>
        <warning>TURN трафик: при неудачном p2p WebRTC пойдет через TURN-сервер — это нагрузка и стоимость. Планируйте
            емкость и бюджет, мониторьте долю relayed-сессий.
        </warning>
        <note>Безопасность и приватность: шифрование в WebRTC обязательное (SRTP/DTLS). Хранить ключи пользователей на
            TURN нельзя — он только ретранслятор.
        </note>
    </chapter>
    <chapter title="Сравнение и выбор протокола">
        <list>
            <li>
                <format style="bold">WS:</format>
                простой двунаправленный канал для событий и UI realtime. Нет жесткой схемы — добавьте свою валидацию.
            </li>
            <li>
                <format style="bold">JSON-RPC:</format>
                легкий RPC на JSON, быстро внедрить, но меньше строгости. Хорош для внутренних инструментов и
                прототипов.
            </li>
            <li>
                <format style="bold">gRPC:</format>
                строгие контракты, генерация кода, потоки, эффективность HTTP/2 + Protobuf. Идеален для сервис-сервис
                API.
            </li>
            <li>
                <format style="bold">GraphQL:</format>
                гибкий отбор данных клиентом, единая точка входа. Требует дисциплины (перфоманс, кеш, N+1).
            </li>
            <li>
                <format style="bold">WebRTC:</format>
                p2p мультимедиа/данные с минимальной задержкой. Нужен сигналинг, STUN/TURN и внимательная сетвая
                архитектура.
            </li>
        </list>
        <tip>Опишите SLA/SLI до выбора: требования к latency (p50/p95), к потерям, к объему сообщений и направлению
            потоков. Это сократит риск неправильного выбора.
        </tip>
    </chapter>
    <chapter title="Практические рекомендации">
        <list>
            <li>Для стриминга телеметрии/событий в UI начните с WS, добавьте схему сообщений (JSON Schema) и
                версионирование.
            </li>
            <li>Для межсервисных контрактов и высокой нагрузки рассмотрите gRPC; для публичного API — REST/GraphQL
                гибрид.
            </li>
            <li>Для видеосвязи и коллаборации — WebRTC с продуманной сигналинг-схемой и метриками доли прямых/relayed
                соединений.
            </li>
            <li>Для быстрых внутренних интеграций подойдет JSON-RPC, но запланируйте миграцию к схематизированному API
                при росте.
            </li>
        </list>
    </chapter>
</topic>